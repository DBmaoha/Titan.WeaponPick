// 11.27: Changed all settings to "titan_soul" entity instead of player
untyped // I really don't like this thing but .SetPlayerSettings() need it...

global function TitanReplace_Init

///// acrossFile utilities
global function TitanReplace_SetTitanLoadoutReplace

///// titanType utilities
global function TitanReplace_BecomeIon
global function TitanReplace_BecomeTone
global function TitanReplace_BecomeRonin
global function TitanReplace_BecomeNorthstar
global function TitanReplace_BecomeScorch
global function TitanReplace_BecomeLegion
global function TitanReplace_BecomeMonarch

struct
{
	// player table
	table<entity, string> soulTitleTable
	table<entity, string> soulPassiveTable // for saving player's starter passiveType
	table<entity, string> soulExecutionRefTable // for saving player's starter executions
} file

void function TitanReplace_Init() 
{
	AddSpawnCallback( "npc_titan", OnTitanSpawned )
	AddCallback_OnPilotBecomesTitan( SetPlayerTitanTitle )

	RegisterDefaultTitanPickCharacters()
}

void function OnTitanSpawned( entity titan )
{
	TitanReplace_SetTitanLoadoutReplace( titan )
}

// default replace
void function TitanReplace_SetTitanLoadoutReplace( entity titan )
{
	// always init everything
	entity titanSoul = titan.GetTitanSoul()
	if( !IsValid( titanSoul ) ) // soul not spawned yet, mostly because disembarking, no worries
		return
	TitanReplace_InitSoulSettings( titanSoul ) // init! robbed monarch from npc pilots won't upgrade your weapons( shield regen only ), which means it's no need to setting a "titanSoul.s.disableTitanPick" for them. perfect

	// following are player titans( pet titans )
	entity player = GetPetTitanOwner( titan )
	if( !IsValid( player ) )
		return
	if ( "spawnWithoutSoul" in titan.s )
	{
		// this is defined in CreateAutoTitanForPlayer_ForTitanTitanReplace_BecomesPilot(), mark the titan as "disembarked" not "hotdropping"
		if ( expect bool ( titan.s.spawnWithoutSoul ) )
			return
	}

	// get passives and executionrefs here
	file.soulPassiveTable[ titanSoul ] = GetTitanPassiveType( titan ) // for saving player's starter passiveType
	file.soulExecutionRefTable[ titanSoul ] = titanSoul.soul.titanLoadout.titanExecution // for saving player's starter executions
	//print( "soul " + string( titanSoul ) + " 's executionRef is: " + file.soulExecutionRefTable[ titanSoul ] )
}

void function SetPlayerTitanTitle( entity player, entity titan )
{
	thread SetPlayerTitanTitle_Threaded( player ) // needs thread, to make soul valid
}

void function SetPlayerTitanTitle_Threaded( entity player )
{
	player.EndSignal( "OnDestroy" )
	WaitFrame()

	entity titanSoul = player.GetTitanSoul()
	if( !IsValid( titanSoul ) )
		return
	if ( titanSoul in file.soulTitleTable )
	{
		string soulSaveTitle = file.soulTitleTable[ titanSoul ]
		if( soulSaveTitle != "" )
		{
			//print( "soulSaveTitle: " + soulSaveTitle )
			if( IsAlive( player ) )
				player.SetTitle( soulSaveTitle )
		}
	}
	//else
	//	print( "can't find titan's title!" )
}

///// settings functions!
void function TitanReplace_InitSoulSettings( entity titanSoul ) // both using for players and titanSouls
{
	if ( !( titanSoul in file.soulTitleTable ) )
		file.soulTitleTable[ titanSoul ] <- ""
	if ( !( titanSoul in file.soulPassiveTable ) )
		file.soulPassiveTable[ titanSoul ] <- ""
	if ( !( titanSoul in file.soulExecutionRefTable ) )
		file.soulExecutionRefTable[ titanSoul ] <- ""
}
///////////


///// loadout functions
void function TitanReplace_BecomeIon( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心启动期间不可以更换装备", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }

			if( !isSpawning )
			{
            	SendHudMessage( player, "更换至 离子 泰坦技能组", -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
				player.SetTitle( "#TITAN_ION" )
			}
			file.soulTitleTable[ soul ] = "#TITAN_ION"
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "ion" )
			TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )

			// spawn as ion
            if( !isPickup )
			{
				//Passives
				string passiveType = file.soulPassiveTable[ soul ]
				RemoveUnmatchedPassive( titan )

				//Skin & Camo
				int skinIndex
				int camoIndex
				bool foundSkin = false
				foreach( entity weapon in titan.GetMainWeapons() )
				{
					if ( !foundSkin )
					{
						skinIndex = weapon.GetSkin()
						camoIndex = weapon.GetCamo()
						foundSkin = true
					}
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}

				//Weapon
				entity newWeapon
                if( passiveType == "Weapon" )
                {
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_particle_accelerator", ["pas_ion_weapon"])
                    GivePassive( titan, ePassives.PAS_ION_WEAPON )
                }
                else if( passiveType == "Offence" )
				{
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_particle_accelerator", ["pas_ion_weapon_ads"])
					GivePassive( titan, ePassives.PAS_ION_WEAPON_ADS )
				}
				else
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_particle_accelerator")
				if ( IsValid( newWeapon ) )
				{
					newWeapon.SetSkin( skinIndex )
					newWeapon.SetCamo( camoIndex )
				}

				//Defence
				if( passiveType == "Defence" )
				{
					titan.GiveOffhandWeapon("mp_titanweapon_vortex_shield_ion", OFFHAND_SPECIAL, ["pas_ion_vortex"] )
					GivePassive( titan, ePassives.PAS_ION_VORTEX )
				}
				else
					titan.GiveOffhandWeapon("mp_titanweapon_vortex_shield_ion", OFFHAND_SPECIAL)

				//Tactical
				if( passiveType == "Tactical" )
				{
					titan.GiveOffhandWeapon("mp_titanability_laser_trip", OFFHAND_ANTIRODEO, ["pas_ion_tripwire"] )
					GivePassive( titan, ePassives.PAS_ION_TRIPWIRE )
				}
				else
					titan.GiveOffhandWeapon("mp_titanability_laser_trip", OFFHAND_ANTIRODEO )

				//Offence
				titan.GiveOffhandWeapon("mp_titanweapon_laser_lite", OFFHAND_ORDNANCE )

				//Titan Core
				if( passiveType == "Core" )
				{
					titan.GiveOffhandWeapon( "mp_titancore_laser_cannon", OFFHAND_EQUIPMENT, ["pas_ion_lasercannon"] )
					GivePassive( titan, ePassives.PAS_ION_LASERCANNON )
				}
				else
					titan.GiveOffhandWeapon( "mp_titancore_laser_cannon", OFFHAND_EQUIPMENT )
			
				//Melee
				titan.GiveOffhandWeapon( "melee_titan_punch_ion", OFFHAND_MELEE )
            }
			
			//Executions
			if ( isPickup )
			{
				if ( GetSoulTitanSubClass( soul ) == "atlas" ) // atlas titan
				{
					ChangeSoulTitanExecution( soul, "execution_ion", "execution_random_0" )
					MeleeSyncedTitan_SetSoulUseExecutionCallback( soul, false )
				}
				else // other titans
				{
					soul.soul.titanLoadout.titanExecution = file.soulExecutionRefTable[ soul ] // restore to starter execution
					MeleeSyncedTitan_SetSoulUseExecutionCallback( soul, true ) // enable execution callbacks for them
				}
			}
        }
	}
}

void function TitanReplace_BecomeTone( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心启动期间不可以更换装备", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }
			if( !isSpawning )
			{
            	SendHudMessage( player, "更换至 强力 泰坦技能组", -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
				player.SetTitle( "#TITAN_TONE" )
			}
			file.soulTitleTable[ soul ] = "#TITAN_TONE"
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "tone" )
			TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )

			// spawn as tone
            if( !isPickup )
			{
				//Passives
				string passiveType = file.soulPassiveTable[ soul ]
				RemoveUnmatchedPassive( titan )

				//Skin & Camo
				int skinIndex
				int camoIndex
				bool foundSkin = false
				foreach( entity weapon in titan.GetMainWeapons() )
				{
					if ( !foundSkin )
					{
						skinIndex = weapon.GetSkin()
						camoIndex = weapon.GetCamo()
						foundSkin = true
					}
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}

				//Weapon
				entity newWeapon
                if( passiveType == "Weapon" )
				{
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_sticky_40mm", ["pas_tone_weapon"])
					GivePassive( titan, ePassives.PAS_TONE_WEAPON )
				}
				else if( passiveType == "Core" )
				{
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_sticky_40mm", ["pas_tone_burst"])
					GivePassive( titan, ePassives.PAS_TONE_BURST )
				}
				else
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_sticky_40mm")
				if ( IsValid( newWeapon ) )
				{
					newWeapon.SetSkin( skinIndex )
					newWeapon.SetCamo( camoIndex )
				}

				//Defence
				if( passiveType == "Defence" )
				{
					titan.GiveOffhandWeapon("mp_titanability_particle_wall", OFFHAND_SPECIAL, ["pas_tone_wall"] )
					GivePassive( titan, ePassives.PAS_TONE_WALL )
				}
				else
					titan.GiveOffhandWeapon("mp_titanability_particle_wall", OFFHAND_SPECIAL)

				//Tactical
				if( passiveType == "Tactical" )
				{
					titan.GiveOffhandWeapon("mp_titanability_sonar_pulse", OFFHAND_ANTIRODEO, ["pas_tone_sonar"] )
					GivePassive( titan, ePassives.PAS_TONE_SONAR )
				}
				else
					titan.GiveOffhandWeapon("mp_titanability_sonar_pulse", OFFHAND_ANTIRODEO )

				//Offence
				if( passiveType == "Offence" )
				{
					titan.GiveOffhandWeapon("mp_titanweapon_tracker_rockets", OFFHAND_ORDNANCE, ["pas_tone_rockets"] )
					GivePassive( titan, ePassives.PAS_TONE_ROCKETS )
				}
				else
					titan.GiveOffhandWeapon("mp_titanweapon_tracker_rockets", OFFHAND_ORDNANCE )
				
				//Titan Core
				titan.GiveOffhandWeapon( "mp_titancore_salvo_core", OFFHAND_EQUIPMENT )
			
				//Melee
				titan.GiveOffhandWeapon( "melee_titan_punch_tone", OFFHAND_MELEE )
            }

			//Executions
			if ( isPickup )
			{
				if ( GetSoulTitanSubClass( soul ) == "atlas" ) // atlas titan
				{
					ChangeSoulTitanExecution( soul, "execution_tone", "execution_random_4" )
					MeleeSyncedTitan_SetSoulUseExecutionCallback( soul, false )
				}
				else // other titans
				{
					soul.soul.titanLoadout.titanExecution = file.soulExecutionRefTable[ soul ] // restore to starter execution
					MeleeSyncedTitan_SetSoulUseExecutionCallback( soul, true ) // enable execution callbacks for them
				}
			}
        }
	}
}

void function TitanReplace_BecomeRonin( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心启动期间不可以更换装备", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }

			if( !isSpawning )
			{
           		SendHudMessage( player, "更换至 浪人 泰坦技能组", -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
            	player.SetTitle( "#TITAN_RONIN" )
			}
			file.soulTitleTable[ soul ] = "#TITAN_RONIN"
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "ronin" )
			TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )

			// spawn as ronin
            if( !isPickup )
			{
				//Passives
				string passiveType = file.soulPassiveTable[ soul ]
				RemoveUnmatchedPassive( titan )

				//Skin & Camo
				int skinIndex
				int camoIndex
				bool foundSkin = false
				foreach( entity weapon in titan.GetMainWeapons() )
				{
					if ( !foundSkin )
					{
						skinIndex = weapon.GetSkin()
						camoIndex = weapon.GetCamo()
						foundSkin = true
					}
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}

				//Weapon
				entity newWeapon
                if( passiveType == "Weapon" )
				{
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_leadwall", ["pas_ronin_weapon"])
					GivePassive( titan, ePassives.PAS_RONIN_WEAPON )
				}
				else
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_leadwall")
				if ( IsValid( newWeapon ) )
				{
					newWeapon.SetSkin( skinIndex )
					newWeapon.SetCamo( camoIndex )
				}
				
				//Defence
				titan.GiveOffhandWeapon("mp_titanability_basic_block", OFFHAND_SPECIAL )

				//Tactical
				if( passiveType == "Defence" )
				{
					titan.GiveOffhandWeapon("mp_titanability_phase_dash", OFFHAND_ANTIRODEO, ["pas_ronin_autoshift"] )
					GivePassive( titan, ePassives.PAS_RONIN_AUTOSHIFT )
				}
				else if( passiveType == "Tactical" )
				{
					titan.GiveOffhandWeapon("mp_titanability_phase_dash", OFFHAND_ANTIRODEO, ["pas_ronin_phase"] )
					GivePassive( titan, ePassives.PAS_RONIN_PHASE )
				}
				else
					titan.GiveOffhandWeapon("mp_titanability_phase_dash", OFFHAND_ANTIRODEO)
				
				//Offence
				if( passiveType == "Offence" )
				{
					titan.GiveOffhandWeapon("mp_titanweapon_arc_wave", OFFHAND_ORDNANCE, ["pas_ronin_arcwave"] )
					GivePassive( titan, ePassives.PAS_RONIN_ARCWAVE )
				}
				else
					titan.GiveOffhandWeapon("mp_titanweapon_arc_wave", OFFHAND_ORDNANCE )

				//Titan Core
				if( passiveType == "Core" )
				{
					titan.GiveOffhandWeapon( "mp_titancore_shift_core", OFFHAND_EQUIPMENT, ["pas_ronin_swordcore"] )
					GivePassive( titan, ePassives.PAS_RONIN_SWORDCORE )
				}
				else
					titan.GiveOffhandWeapon( "mp_titancore_shift_core", OFFHAND_EQUIPMENT )
			
				//Melee
				titan.GiveOffhandWeapon( "melee_titan_sword", OFFHAND_MELEE )
            }

			//Executions
			if ( isPickup )
			{
				if ( GetSoulTitanSubClass( soul ) == "stryder" ) // stryder titan
				{
					ChangeSoulTitanExecution( soul, "execution_ronin", "execution_random_3" )
					MeleeSyncedTitan_SetSoulUseExecutionCallback( soul, false )
				}
				else // other titans
				{
					soul.soul.titanLoadout.titanExecution = file.soulExecutionRefTable[ soul ] // restore to starter execution
					MeleeSyncedTitan_SetSoulUseExecutionCallback( soul, true ) // enable execution callbacks for them
				}
			}
        }
	}
}

void function TitanReplace_BecomeNorthstar( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心启动期间不可以更换装备", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }
            
			if( !isSpawning )
			{
            	SendHudMessage( player, "更换至 北极星 泰坦技能组", -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
            	player.SetTitle( "#TITAN_NORTHSTAR" )
			}
			file.soulTitleTable[ soul ] = "#TITAN_NORTHSTAR"
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "northstar" )
			TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )

			// spawn as northstar
            if( !isPickup )
			{
				//Passives
				string passiveType = file.soulPassiveTable[ soul ]
				RemoveUnmatchedPassive( titan )

				//Skin & Camo
				int skinIndex
				int camoIndex
				bool foundSkin = false
				foreach( entity weapon in titan.GetMainWeapons() )
				{
					if ( !foundSkin )
					{
						skinIndex = weapon.GetSkin()
						camoIndex = weapon.GetCamo()
						foundSkin = true
					}
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}
				
				//Weapon
				entity newWeapon
                if( passiveType == "Weapon" )
				{
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_sniper", ["pas_northstar_weapon"])
					GivePassive( titan, ePassives.PAS_NORTHSTAR_WEAPON )
				}
				else if( passiveType == "Tactical" )
				{
					newWeapon = titan.GiveWeapon ("mp_titanweapon_sniper", ["pas_northstar_optics"])
					GivePassive( titan, ePassives.PAS_NORTHSTAR_OPTICS )
				}
				else
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_sniper")
				if ( IsValid( newWeapon ) )
				{
					newWeapon.SetSkin( skinIndex )
					newWeapon.SetCamo( camoIndex )
				}
				
				//Defence
				if( passiveType == "Defence" )
				{
					titan.GiveOffhandWeapon("mp_titanability_tether_trap", OFFHAND_SPECIAL, ["pas_northstar_trap"] )
					GivePassive( titan, ePassives.PAS_NORTHSTAR_TRAP )
				}
				else
					titan.GiveOffhandWeapon("mp_titanability_tether_trap", OFFHAND_SPECIAL )

				//Tacticals, northstar is a bit special
				if( passiveType == "Core" )
					titan.GiveOffhandWeapon("mp_titanability_hover", OFFHAND_ANTIRODEO, ["pas_northstar_flightcore"] )
				else
					titan.GiveOffhandWeapon("mp_titanability_hover", OFFHAND_ANTIRODEO)

				//Offence
				if( passiveType == "Offence" )
				{
					titan.GiveOffhandWeapon("mp_titanweapon_dumbfire_rockets", OFFHAND_ORDNANCE, ["pas_northstar_cluster"] )
					GivePassive( titan, ePassives.PAS_NORTHSTAR_CLUSTER )
				}
				else
					titan.GiveOffhandWeapon("mp_titanweapon_dumbfire_rockets", OFFHAND_ORDNANCE )

				//Titan Core
				if( passiveType == "Core" )
				{
					titan.GiveOffhandWeapon( "mp_titancore_flight_core", OFFHAND_EQUIPMENT, ["pas_northstar_flightcore"] )
					GivePassive( titan, ePassives.PAS_NORTHSTAR_FLIGHTCORE )
				}
				else
					titan.GiveOffhandWeapon( "mp_titancore_flight_core", OFFHAND_EQUIPMENT )
			}
		
            //Melee
            titan.GiveOffhandWeapon( "melee_titan_punch_northstar", OFFHAND_MELEE )

			//Executions
			if ( isPickup )
			{
				if ( GetSoulTitanSubClass( soul ) == "stryder" ) // stryder titan
				{
					ChangeSoulTitanExecution( soul, "execution_northstar", "execution_random_2" )
					MeleeSyncedTitan_SetSoulUseExecutionCallback( soul, false )
				}
				else // other titans
				{
					soul.soul.titanLoadout.titanExecution = file.soulExecutionRefTable[ soul ] // restore to starter execution
					MeleeSyncedTitan_SetSoulUseExecutionCallback( soul, true ) // enable execution callbacks for them
				}
			}
        }
	}
}

void function TitanReplace_BecomeScorch( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心启动期间不可以更换装备", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }

			if( !isSpawning )
			{
            	SendHudMessage( player, "更换至 烈焰 泰坦技能组", -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
            	player.SetTitle( "#TITAN_SCORCH" )
			}
			file.soulTitleTable[ soul ] = "#TITAN_SCORCH"
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "scorch" )
			TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )

			// spawn as scorch
            if( !isPickup )
			{
				//Passives
				string passiveType = file.soulPassiveTable[ soul ]
				RemoveUnmatchedPassive( titan )

				//Skin & Camo
				int skinIndex
				int camoIndex
				bool foundSkin = false
				foreach( entity weapon in titan.GetMainWeapons() )
				{
					if ( !foundSkin )
					{
						skinIndex = weapon.GetSkin()
						camoIndex = weapon.GetCamo()
						foundSkin = true
					}
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}

				//Weapon
				entity newWeapon
                if( passiveType == "Weapon" )
				{
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_meteor", ["pas_scorch_weapon"])
					GivePassive( titan, ePassives.PAS_SCORCH_WEAPON )
				}
				else
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_meteor")
				if ( IsValid( newWeapon ) )
				{
					newWeapon.SetSkin( skinIndex )
					newWeapon.SetCamo( camoIndex )
				}
				
				//Defence
				if( passiveType == "Defence" )
				{
					titan.GiveOffhandWeapon("mp_titanweapon_heat_shield", OFFHAND_SPECIAL, ["pas_scorch_shield"] )
					GivePassive( titan, ePassives.PAS_SCORCH_SHIELD )
				}
				else
					titan.GiveOffhandWeapon("mp_titanweapon_heat_shield", OFFHAND_SPECIAL )

				//Tacticals, scorch is a bit special
				if( passiveType == "Tactical" )
					GivePassive( titan, ePassives.PAS_SCORCH_SELFDMG )
				titan.GiveOffhandWeapon("mp_titanability_slow_trap", OFFHAND_ANTIRODEO )

				//Offence
				if( passiveType == "Offence" )
				{
					titan.GiveOffhandWeapon("mp_titanweapon_flame_wall", OFFHAND_ORDNANCE, ["pas_scorch_firewall"] )
					GivePassive( titan, ePassives.PAS_SCORCH_FIREWALL )
				}
				else
					titan.GiveOffhandWeapon("mp_titanweapon_flame_wall", OFFHAND_ORDNANCE )

				//Titan Core
				if( passiveType == "Core" )
				{
					titan.GiveOffhandWeapon( "mp_titancore_flame_wave", OFFHAND_EQUIPMENT, ["pas_scorch_flamecore"] )
					GivePassive( titan, ePassives.PAS_SCORCH_FLAMECORE )
				}
				else
					titan.GiveOffhandWeapon( "mp_titancore_flame_wave", OFFHAND_EQUIPMENT )
			
				//Melee
				titan.GiveOffhandWeapon( "melee_titan_punch_scorch", OFFHAND_MELEE )
            }

			// pick up scorch loadout
			if ( isPickup )
			{
				//Passives
				if ( SoulHasPassive( soul, ePassives.PAS_SCORCH_SELFDMG ) )
					soul.SetPreventCrits( true )

				//Executions
				if ( GetSoulTitanSubClass( soul ) == "ogre" ) // ogre titan
				{
					ChangeSoulTitanExecution( soul, "execution_scorch", "execution_random_1" )
					MeleeSyncedTitan_SetSoulUseExecutionCallback( soul, false )
				}
				else // other titans
				{
					soul.soul.titanLoadout.titanExecution = file.soulExecutionRefTable[ soul ] // restore to starter execution
					MeleeSyncedTitan_SetSoulUseExecutionCallback( soul, true ) // enable execution callbacks for them
				}
			}
        }
	}
}

void function TitanReplace_BecomeLegion( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心启动期间不可以更换装备", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }

			if( !isSpawning )
			{
            	SendHudMessage( player, "更换至 军团 泰坦技能组", -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
            	player.SetTitle( "#TITAN_LEGION" )
			}
			file.soulTitleTable[ soul ] = "#TITAN_LEGION"
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "legion" )
			TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )

			// spawn as legion
            if( !isPickup )
			{
				//Passives
				string passiveType = file.soulPassiveTable[ soul ]
				RemoveUnmatchedPassive( titan )

				//Skin & Camo
				int skinIndex
				int camoIndex
				bool foundSkin = false
				foreach( entity weapon in titan.GetMainWeapons() )
				{
					if ( !foundSkin )
					{
						skinIndex = weapon.GetSkin()
						camoIndex = weapon.GetCamo()
						foundSkin = true
					}
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}

				//Weapon
                if( passiveType == "Weapon" )
				{
                    titan.GiveWeapon ("mp_titanweapon_predator_cannon", ["pas_legion_weapon"])
					GivePassive( titan, ePassives.PAS_LEGION_WEAPON)
				}
				if( passiveType == "Tactical" )
				{
                    titan.GiveWeapon ("mp_titanweapon_predator_cannon", ["pas_legion_spinup"])
					GivePassive( titan, ePassives.PAS_LEGION_SPINUP )
				}
				else
                    titan.GiveWeapon ("mp_titanweapon_predator_cannon")
				
				//Defence
				if( passiveType == "Defence" )
				{
					titan.GiveOffhandWeapon("mp_titanability_gun_shield", OFFHAND_SPECIAL, ["pas_legion_gunshield"] )
					GivePassive( titan, ePassives.PAS_LEGION_GUNSHIELD )
				}
				else
					titan.GiveOffhandWeapon("mp_titanability_gun_shield", OFFHAND_SPECIAL )

				//Tacticals
				titan.GiveOffhandWeapon("mp_titanability_ammo_swap", OFFHAND_ANTIRODEO )

				//Offence
				if( passiveType == "Offence" )
				{
					titan.GiveOffhandWeapon("mp_titanability_power_shot", OFFHAND_ORDNANCE, ["pas_legion_chargeshot"] )
					GivePassive( titan, ePassives.PAS_LEGION_CHARGESHOT )
				}
				else
					titan.GiveOffhandWeapon("mp_titanability_power_shot", OFFHAND_ORDNANCE )
				
				//Titan Core
				if( passiveType == "Core" )
				{
					titan.GiveOffhandWeapon( "mp_titancore_siege_mode", OFFHAND_EQUIPMENT, ["pas_legion_smartcore"] )
					GivePassive( titan, ePassives.PAS_LEGION_SMARTCORE )
				}
				else
					titan.GiveOffhandWeapon( "mp_titancore_siege_mode", OFFHAND_EQUIPMENT )
			
				//Melee
				titan.GiveOffhandWeapon( "melee_titan_punch_legion", OFFHAND_MELEE )
            }

			if ( GetSoulTitanSubClass( soul ) == "ogre" ) // ogre titan
			{
				ChangeSoulTitanExecution( soul, "execution_legion", "execution_random_5" )
				MeleeSyncedTitan_SetSoulUseExecutionCallback( soul, false )
			}
			else // other titans
			{
				soul.soul.titanLoadout.titanExecution = file.soulExecutionRefTable[ soul ] // restore to starter execution
				MeleeSyncedTitan_SetSoulUseExecutionCallback( soul, true ) // enable execution callbacks for them
			}
        }
	}
}

void function TitanReplace_BecomeMonarch( entity titan, bool isPickup = false, bool isSpawning = false )
{
    if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心启动期间不可以更换装备", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }

			if( !isSpawning )
			{
            	SendHudMessage( player, "更换至 帝王 泰坦技能组", -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
            	player.SetTitle( "#TITAN_VANGUARD" )
			}
			file.soulTitleTable[ soul ] = "#TITAN_VANGUARD"
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "vanguard" )
			TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )

			// spawn as monarch
			if ( !isPickup )
			{
				//Passives
				string passiveType = file.soulPassiveTable[ soul ]
				RemoveUnmatchedPassive( titan )

				//Skin & Camo
				int skinIndex
				int camoIndex
				bool foundSkin = false
				foreach( entity weapon in titan.GetMainWeapons() )
				{
					if ( !foundSkin )
					{
						skinIndex = weapon.GetSkin()
						camoIndex = weapon.GetCamo()
						foundSkin = true
					}
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}

				//Weapon
				entity newWeapon = titan.GiveWeapon ("mp_titanweapon_xo16_vanguard")
				newWeapon.SetSkin( skinIndex )
				newWeapon.SetCamo( camoIndex )

				
				//Defence
				titan.GiveOffhandWeapon("mp_titanweapon_stun_laser", OFFHAND_SPECIAL )

				//Tactical
				titan.GiveOffhandWeapon("mp_titanability_rearm", OFFHAND_ANTIRODEO )

				//Offence
				titan.GiveOffhandWeapon("mp_titanweapon_salvo_rockets", OFFHAND_ORDNANCE )

				//Titan Core
				titan.GiveOffhandWeapon( "mp_titancore_upgrade", OFFHAND_EQUIPMENT )
				//soul.SetTitanSoulNetInt( "upgradeCount", 3 ) // so player can't upgrade, they can only receive shields
			
				//Melee
				titan.GiveOffhandWeapon( "melee_titan_punch_vanguard", OFFHAND_MELEE )
			}

			// switch to monarch loadout
			if ( isPickup )
			{
				int upgradeCount = soul.GetTitanSoulNetInt( "upgradeCount" )
				// bodygroup
				if ( upgradeCount >= 1 ) // upgraded
				{
					int statesIndex = titan.FindBodyGroup( "states" )
					if ( statesIndex > 0 )
						titan.SetBodygroup( statesIndex, 1 )
				}

				//Passives
				// maelstrom
				if ( upgradeCount >= 2 && SoulHasPassive( soul, ePassives.PAS_VANGUARD_CORE5 ) )
				{
					entity smokeWeapon = titan.GetOffhandWeapon( OFFHAND_INVENTORY )
					if ( IsValid( smokeWeapon ) )
					{
						array<string> mods = smokeWeapon.GetMods()
						mods.append( "maelstrom" )
						smokeWeapon.SetMods( mods )
					}
				}
				// superior chassis
				if ( upgradeCount >= 3 && SoulHasPassive( soul, ePassives.PAS_VANGUARD_CORE8 ) )
				{
					if ( !GetDoomedState( titan ) )
					{
						int currentHealth = titan.GetHealth()
						array<string> settingMods = titan.GetPlayerSettingsMods()
						settingMods.append( "core_health_upgrade" )
						titan.SetPlayerSettingsWithMods( titan.GetPlayerSettings(), settingMods )
						int maxHealth = titan.GetMaxHealth()
						titan.SetHealth( min( currentHealth, maxHealth ) )

						//Hacky Hack - Append core_health_upgrade to setFileMods so that we have a way to check that this upgrade is active.
						soul.soul.titanLoadout.setFileMods.append( "core_health_upgrade" )
					}
					
					// here goes a problem: a monarch with superior chassis cannot update it's health bar if it switch to another final upgrade with same upgradeCount
					soul.SetPreventCrits( true )
				}

				//Executions
				if ( GetSoulTitanSubClass( soul ) == "atlas" ) // atlas titan
				{
					ChangeSoulTitanExecution( soul, "execution_vangard", "execution_random_6", false ) // monarch don't have _prime suffix ones
					MeleeSyncedTitan_SetSoulUseExecutionCallback( soul, false )
				}
				else // other titans
				{
					soul.soul.titanLoadout.titanExecution = file.soulExecutionRefTable[ soul ] // restore to starter execution
					MeleeSyncedTitan_SetSoulUseExecutionCallback( soul, true ) // enable execution callbacks for them
				}
			}
        }
	}
}

///// titan pick loadout functions
void function RegisterDefaultTitanPickCharacters()
{
	RegisterIonTitanPick()
	RegisterToneTitanPick()
	RegisterMonarchTitanPick()
	RegisterRoninTitanPick()
	RegisterNorthstarTitanPick()
	RegisterScorchTitanPick()
	RegisterLegionTitanPick()
}

// ion
void function RegisterIonTitanPick()
{
	TitanPick_RegisterTitanWeaponDrop( "ion", IonWeaponWeaponPropFunc, IonWeaponDisplayNameFunc, TitanReplace_BecomeIon )

	// passives
	TitanPick_AddChangablePassive( ePassives.PAS_ION_TRIPWIRE )
	TitanPick_AddChangablePassive( ePassives.PAS_ION_VORTEX )
	TitanPick_AddChangablePassive( ePassives.PAS_ION_LASERCANNON )
	TitanPick_AddChangablePassive( ePassives.PAS_ION_WEAPON )
	TitanPick_AddChangablePassive( ePassives.PAS_ION_WEAPON_ADS )

	// classmods
	TitanPick_AddChangableClassMod( "fd_energy_regen" )
	TitanPick_AddChangableClassMod( "fd_energy_max" )
}

entity function IonWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()

	if ( weaponName != "mp_titanweapon_particle_accelerator" )
		return // return empty will cancel the weapon drop

	asset modelName = $"models/weapons/titan_particle_accelerator/w_titan_particle_accelerator.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function IonWeaponDisplayNameFunc( entity weapon )
{
	entity titan = weapon.GetWeaponOwner()
	if ( !IsValid( titan ) )
		return ""
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return ""

	string weaponName = weapon.GetWeaponClassName()
	if ( weaponName != "mp_titanweapon_particle_accelerator" )
		return "" // return empty will cancel the weapon drop
	
	array<string> primaryMods = weapon.GetMods()
	entity special = titan.GetOffhandWeapon( OFFHAND_SPECIAL )
	entity ordnance = titan.GetOffhandWeapon( OFFHAND_ORDNANCE )
	entity antiRodeo = titan.GetOffhandWeapon( OFFHAND_ANTIRODEO )
	entity core = titan.GetOffhandWeapon( OFFHAND_EQUIPMENT )
	array<string> specialMods = []
	array<string> ordnanceMods = []
	array<string> antiRodeoMods = []
	array<string> coreMods = []
	if ( IsValid( special ) )
		specialMods = special.GetMods()
	if ( IsValid( ordnance ) )
		ordnanceMods = ordnance.GetMods()
	if ( IsValid( antiRodeo ) )
		antiRodeoMods = antiRodeo.GetMods()
	if ( IsValid( core ) )
		coreMods = core.GetMods()

	string displayName = "離子 技能組"
	if ( SoulHasPassive( soul, ePassives.PAS_ION_WEAPON ) || primaryMods.contains( "pas_ion_weapon" ) )
		displayName += "【纏結能量】"
	else if ( antiRodeoMods.contains( "pas_ion_tripwire" ) )
		displayName += "【零點絆線】"
	else if ( specialMods.contains( "pas_ion_vortex" ) )
		displayName += "【漩渦擴大器】"
	else if ( coreMods.contains( "pas_ion_lasercannon" ) )
		displayName += "【大型火砲】"
	else if ( primaryMods.contains( "pas_ion_weapon_ads" ) )
		displayName += "【折射鏡片】"

	return displayName
}

// tone
void function RegisterToneTitanPick()
{
	TitanPick_RegisterTitanWeaponDrop( "tone", ToneWeaponWeaponPropFunc, ToneWeaponDisplayNameFunc, TitanReplace_BecomeTone )

	// passives
	TitanPick_AddChangablePassive( ePassives.PAS_TONE_BURST )
	TitanPick_AddChangablePassive( ePassives.PAS_TONE_ROCKETS )
	TitanPick_AddChangablePassive( ePassives.PAS_TONE_SONAR )
	TitanPick_AddChangablePassive( ePassives.PAS_TONE_WALL )
	TitanPick_AddChangablePassive( ePassives.PAS_TONE_WEAPON )
}

entity function ToneWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()

	if ( weaponName != "mp_titanweapon_sticky_40mm" )
		return // return empty will cancel the weapon drop

	asset modelName = $"models/weapons/thr_40mm/w_thr_40mm.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function ToneWeaponDisplayNameFunc( entity weapon )
{
	entity titan = weapon.GetWeaponOwner()
	if ( !IsValid( titan ) )
		return ""
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return ""

	string weaponName = weapon.GetWeaponClassName()
	if ( weaponName != "mp_titanweapon_sticky_40mm" )
		return "" // return empty will cancel the weapon drop

	array<string> primaryMods = weapon.GetMods()
	entity special = titan.GetOffhandWeapon( OFFHAND_SPECIAL )
	entity ordnance = titan.GetOffhandWeapon( OFFHAND_ORDNANCE )
	entity antiRodeo = titan.GetOffhandWeapon( OFFHAND_ANTIRODEO )
	array<string> specialMods = []
	array<string> ordnanceMods = []
	array<string> antiRodeoMods = []
	if ( IsValid( special ) )
		specialMods = special.GetMods()
	if ( IsValid( ordnance ) )
		ordnanceMods = ordnance.GetMods()
	if ( IsValid( antiRodeo ) )
		antiRodeoMods = antiRodeo.GetMods()
	
	string displayName = "強力 技能組"
	if ( primaryMods.contains( "pas_tone_weapon" ) )
        displayName += "【強化追蹤彈藥】"
	else if ( SoulHasPassive( soul, ePassives.PAS_TONE_WALL ) || specialMods.contains( "pas_tone_wall" ) )
		displayName += "【強化粒子障壁】"
	else if ( antiRodeoMods.contains( "pas_tone_sonar" ) )
		displayName += "【脈衝回波】"
	else if ( ordnanceMods.contains( "pas_tone_rockets" ) )
		displayName += "【脈衝回波】"
	else if ( primaryMods.contains( "pas_tone_burst" ) )
		displayName += "【連發填充器】"

	return displayName
}

// ronin
void function RegisterRoninTitanPick()
{
	TitanPick_RegisterTitanWeaponDrop( "ronin", RoninWeaponWeaponPropFunc, RoninWeaponDisplayNameFunc, TitanReplace_BecomeRonin )
	
	// invalid mods
	TitanPick_AddIllegalWeaponMod( "super_charged" )

	// passives
	TitanPick_AddChangablePassive( ePassives.PAS_RONIN_ARCWAVE )
	TitanPick_AddChangablePassive( ePassives.PAS_RONIN_AUTOSHIFT )
	TitanPick_AddChangablePassive( ePassives.PAS_RONIN_PHASE )
	TitanPick_AddChangablePassive( ePassives.PAS_RONIN_SWORDCORE )
	TitanPick_AddChangablePassive( ePassives.PAS_RONIN_WEAPON )
}

entity function RoninWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()

	if ( weaponName != "mp_titanweapon_leadwall" )
		return // return empty will cancel the weapon drop

	asset modelName = $"models/weapons/titan_triple_threat/w_titan_triple_threat.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function RoninWeaponDisplayNameFunc( entity weapon )
{
	entity titan = weapon.GetWeaponOwner()
	if ( !IsValid( titan ) )
		return ""
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return ""

	string weaponName = weapon.GetWeaponClassName()
	if ( weaponName != "mp_titanweapon_leadwall" )
		return "" // return empty will cancel the weapon drop
	
	array<string> primaryMods = weapon.GetMods()
	entity special = titan.GetOffhandWeapon( OFFHAND_SPECIAL )
	entity ordnance = titan.GetOffhandWeapon( OFFHAND_ORDNANCE )
	entity antiRodeo = titan.GetOffhandWeapon( OFFHAND_ANTIRODEO )
	entity core = titan.GetOffhandWeapon( OFFHAND_EQUIPMENT )
	array<string> specialMods = []
	array<string> ordnanceMods = []
	array<string> antiRodeoMods = []
	array<string> coreMods = []
	if ( IsValid( special ) )
		specialMods = special.GetMods()
	if ( IsValid( ordnance ) )
		ordnanceMods = ordnance.GetMods()
	if ( IsValid( antiRodeo ) )
		antiRodeoMods = antiRodeo.GetMods()
	if ( IsValid( core ) )
		coreMods = core.GetMods()

	string displayName = "浪人 技能組"
	if ( primaryMods.contains( "pas_ronin_weapon" ) )
		displayName += "【彈跳彈藥】"
	else if ( ordnanceMods.contains( "pas_ronin_arcwave" ) )
		displayName += "【雷暴】"
	else if ( SoulHasPassive( soul, ePassives.PAS_RONIN_AUTOSHIFT ) || antiRodeoMods.contains( "pas_ronin_autoshift" ) )
		displayName += "【瞬間反應】"
	else if ( SoulHasPassive( soul, ePassives.PAS_RONIN_SWORDCORE ) || coreMods.contains( "pas_ronin_swordcore" ) )
		displayName += "【高地戰士】"
	else if ( antiRodeoMods.contains( "pas_ronin_phase" ) )
		displayName += "【時間異常】"

	return displayName
}

// northstar
void function RegisterNorthstarTitanPick()
{
	TitanPick_RegisterTitanWeaponDrop( "northstar", NorthstarWeaponWeaponPropFunc, NorthstarWeaponDisplayNameFunc, TitanReplace_BecomeNorthstar )

	// passives
	TitanPick_AddChangablePassive( ePassives.PAS_NORTHSTAR_CLUSTER )
	TitanPick_AddChangablePassive( ePassives.PAS_NORTHSTAR_FLIGHTCORE )
	TitanPick_AddChangablePassive( ePassives.PAS_NORTHSTAR_OPTICS )
	TitanPick_AddChangablePassive( ePassives.PAS_NORTHSTAR_TRAP )
	TitanPick_AddChangablePassive( ePassives.PAS_NORTHSTAR_WEAPON )
}

entity function NorthstarWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()

	if ( weaponName != "mp_titanweapon_sniper" )
		return // return empty will cancel the weapon drop

	asset modelName = $"models/weapons/titan_sniper_rifle/w_titan_sniper_rifle.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function NorthstarWeaponDisplayNameFunc( entity weapon )
{
	entity titan = weapon.GetWeaponOwner()
	if ( !IsValid( titan ) )
		return ""
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return ""

	string weaponName = weapon.GetWeaponClassName()
	if ( weaponName != "mp_titanweapon_sniper" )
		return "" // return empty will cancel the weapon drop
	
	array<string> primaryMods = weapon.GetMods()
	entity special = titan.GetOffhandWeapon( OFFHAND_SPECIAL )
	entity ordnance = titan.GetOffhandWeapon( OFFHAND_ORDNANCE )
	entity antiRodeo = titan.GetOffhandWeapon( OFFHAND_ANTIRODEO )
	entity core = titan.GetOffhandWeapon( OFFHAND_EQUIPMENT )
	array<string> specialMods = []
	array<string> ordnanceMods = []
	array<string> antiRodeoMods = []
	array<string> coreMods = []
	if ( IsValid( special ) )
		specialMods = special.GetMods()
	if ( IsValid( ordnance ) )
		ordnanceMods = ordnance.GetMods()
	if ( IsValid( antiRodeo ) )
		antiRodeoMods = antiRodeo.GetMods()
	if ( IsValid( core ) )
		coreMods = core.GetMods()

	string displayName = "北極星 技能組"
	if ( primaryMods.contains( "pas_northstar_weapon" ) )
		displayName += "【穿刺射擊】"
	else if ( ordnanceMods.contains( "pas_northstar_cluster" ) )
		displayName += "【強化負載重量】"
	else if ( specialMods.contains( "pas_northstar_trap" ) )
		displayName += "【雙重陷阱】"
	else if ( SoulHasPassive( soul, ePassives.PAS_NORTHSTAR_FLIGHTCORE ) || coreMods.contains( "pas_northstar_flightcore" ) )
		displayName += "【毒蛇推進器】"
	else if ( primaryMods.contains( "pas_northstar_optics" ) )
		displayName += "【威脅光鏡】"

	return displayName
}

// scorch
void function RegisterScorchTitanPick()
{
	TitanPick_RegisterTitanWeaponDrop( "scorch", ScorchWeaponWeaponPropFunc, ScorchWeaponDisplayNameFunc, TitanReplace_BecomeScorch, SwitchOffScorchLoadout )

	// passives
	TitanPick_AddChangablePassive( ePassives.PAS_SCORCH_FIREWALL )
	TitanPick_AddChangablePassive( ePassives.PAS_SCORCH_FLAMECORE )
	TitanPick_AddChangablePassive( ePassives.PAS_SCORCH_SELFDMG )
	TitanPick_AddChangablePassive( ePassives.PAS_SCORCH_SHIELD )
	TitanPick_AddChangablePassive( ePassives.PAS_SCORCH_WEAPON )
}

entity function ScorchWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()

	if ( weaponName != "mp_titanweapon_meteor" )
		return // return empty will cancel the weapon drop
	
	asset modelName = $"models/weapons/titan_thermite_launcher/w_titan_thermite_launcher.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function ScorchWeaponDisplayNameFunc( entity weapon )
{
	entity titan = weapon.GetWeaponOwner()
	if ( !IsValid( titan ) )
		return ""
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return ""

	string weaponName = weapon.GetWeaponClassName()
	if ( weaponName != "mp_titanweapon_meteor" )
		return "" // return empty will cancel the weapon drop
	
	array<string> primaryMods = weapon.GetMods()
	entity special = titan.GetOffhandWeapon( OFFHAND_SPECIAL )
	entity ordnance = titan.GetOffhandWeapon( OFFHAND_ORDNANCE )
	entity antiRodeo = titan.GetOffhandWeapon( OFFHAND_ANTIRODEO )
	entity core = titan.GetOffhandWeapon( OFFHAND_EQUIPMENT )
	array<string> specialMods = []
	array<string> ordnanceMods = []
	array<string> antiRodeoMods = []
	array<string> coreMods = []
	if ( IsValid( special ) )
		specialMods = special.GetMods()
	if ( IsValid( ordnance ) )
		ordnanceMods = ordnance.GetMods()
	if ( IsValid( antiRodeo ) )
		antiRodeoMods = antiRodeo.GetMods()
	if ( IsValid( core ) )
		coreMods = core.GetMods()

	string displayName = "烈焰 技能組"
	if ( primaryMods.contains( "pas_scorch_weapon" ) )
		displayName += "【野火投射器】"
	else if ( SoulHasPassive( soul, ePassives.PAS_SCORCH_SELFDMG ) )
		displayName += "【回火加工武裝】"
	else if ( specialMods.contains( "pas_scorch_shield" ) )
		displayName += "【煉獄護罩】"
	else if ( ordnanceMods.contains( "pas_scorch_firewall" ) )
		displayName += "【增強火力】"
	else if ( coreMods.contains( "pas_scorch_flamecore" ) )
		displayName += "【一片焦土】"

	return displayName
}

void function SwitchOffScorchLoadout( entity titan )
{
	entity soul = titan.GetTitanSoul()
	if ( IsValid( soul ) )
	{
		if ( SoulHasPassive( soul, ePassives.PAS_SCORCH_SELFDMG ) )
			soul.SetPreventCrits( false ) // clean up
	}
}

// legion
void function RegisterLegionTitanPick()
{
	TitanPick_RegisterTitanWeaponDrop( "legion", LegionWeaponWeaponPropFunc, LegionWeaponDisplayNameFunc, TitanReplace_BecomeLegion )
	
	// invalid mods
	TitanPick_AddIllegalWeaponMod( "Smart_Core" )
	TitanPick_AddIllegalWeaponMod( "LongRangeAmmo" )
	TitanPick_AddIllegalWeaponMod( "CloseRangePowerShot" )
	TitanPick_AddIllegalWeaponMod( "pas_CloseRangePowerShot" )
	TitanPick_AddIllegalWeaponMod( "LongRangePowerShot" )
	TitanPick_AddIllegalWeaponMod( "pas_LongRangePowerShot" )

	// passives
	TitanPick_AddChangablePassive( ePassives.PAS_LEGION_CHARGESHOT )
	TitanPick_AddChangablePassive( ePassives.PAS_LEGION_GUNSHIELD )
	TitanPick_AddChangablePassive( ePassives.PAS_LEGION_SMARTCORE )
	TitanPick_AddChangablePassive( ePassives.PAS_LEGION_SPINUP )
	TitanPick_AddChangablePassive( ePassives.PAS_LEGION_WEAPON )
}

entity function LegionWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()

	if ( weaponName != "mp_titanweapon_predator_cannon" )
		return // return empty will cancel the weapon drop
	
	asset modelName = $"models/weapons/titan_predator/w_titan_predator.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function LegionWeaponDisplayNameFunc( entity weapon )
{
	entity titan = weapon.GetWeaponOwner()
	if ( !IsValid( titan ) )
		return ""
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return ""

	string weaponName = weapon.GetWeaponClassName()
	if ( weaponName != "mp_titanweapon_predator_cannon" )
		return "" // return empty will cancel the weapon drop
	
	array<string> primaryMods = weapon.GetMods()
	entity special = titan.GetOffhandWeapon( OFFHAND_SPECIAL )
	entity ordnance = titan.GetOffhandWeapon( OFFHAND_ORDNANCE )
	entity antiRodeo = titan.GetOffhandWeapon( OFFHAND_ANTIRODEO )
	entity core = titan.GetOffhandWeapon( OFFHAND_EQUIPMENT )
	array<string> specialMods = []
	array<string> ordnanceMods = []
	array<string> antiRodeoMods = []
	array<string> coreMods = []
	if ( IsValid( special ) )
		specialMods = special.GetMods()
	if ( IsValid( ordnance ) )
		ordnanceMods = ordnance.GetMods()
	if ( IsValid( antiRodeo ) )
		antiRodeoMods = antiRodeo.GetMods()
	if ( IsValid( core ) )
		coreMods = core.GetMods()

	string displayName = "軍團 技能組"
	if ( primaryMods.contains( "pas_legion_weapon" ) )
		displayName += "【強化彈藥容量】"
	else if ( coreMods.contains( "pas_legion_smartcore" ) )
		displayName += "【感測器陣列】"
	else if ( SoulHasPassive( soul, ePassives.PAS_LEGION_GUNSHIELD ) || specialMods.contains( "pas_legion_gunshield" ) )
		displayName += "【堡壘】"
	else if ( primaryMods.contains( "pas_legion_spinup" ) )
		displayName += "【輕合金】"
	else if ( ordnanceMods.contains( "pas_legion_chargeshot" ) )
		displayName += "【隱藏部件】"

	return displayName
}

// monarch, not sure if it's named "vanguard"
void function RegisterMonarchTitanPick()
{
	TitanPick_RegisterTitanWeaponDrop( "vanguard", MonarchWeaponWeaponPropFunc, MonarchWeaponDisplayNameFunc, TitanReplace_BecomeMonarch, SwitchOffMonarchLoadout )

	// passives
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_COREMETER )
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_SHIELD )
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_REARM )
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_DOOM )

	// core upgrades
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_CORE1 )
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_CORE2 )
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_CORE3 )
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_CORE4 )
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_CORE5 )
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_CORE6 )
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_CORE7 )
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_CORE8 )
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_CORE9 )

	// classmods
	//TitanPick_AddChangableClassMod( "core_health_upgrade" ) // should be handled by switchoff funcs
}

entity function MonarchWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()

	if ( weaponName != "mp_titanweapon_xo16_vanguard" )
		return // return empty will cancel the weapon drop

	asset modelName = $"models/weapons/titan_xo16_shorty/w_xo16shorty.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function MonarchWeaponDisplayNameFunc( entity weapon )
{
	entity titan = weapon.GetWeaponOwner()
	if ( !IsValid( titan ) )
		return ""
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return ""

	string weaponName = weapon.GetWeaponClassName()
	if ( weaponName != "mp_titanweapon_xo16_vanguard" )
		return "" // return empty will cancel the weapon drop

	array<string> primaryMods = weapon.GetMods()
	entity special = titan.GetOffhandWeapon( OFFHAND_SPECIAL )
	entity ordnance = titan.GetOffhandWeapon( OFFHAND_ORDNANCE )
	entity antiRodeo = titan.GetOffhandWeapon( OFFHAND_ANTIRODEO )
	array<string> specialMods = []
	array<string> ordnanceMods = []
	array<string> antiRodeoMods = []
	if ( IsValid( special ) )
		specialMods = special.GetMods()
	if ( IsValid( ordnance ) )
		ordnanceMods = ordnance.GetMods()
	if ( IsValid( antiRodeo ) )
		antiRodeoMods = antiRodeo.GetMods()
	
	// mornach has variant mods
	// passives
	string passive = ""
	if ( SoulHasPassive( soul, ePassives.PAS_VANGUARD_SHIELD ) || specialMods.contains( "pas_vanguard_shield" ) )
		passive = "防護罩放大器"
	else if ( SoulHasPassive( soul, ePassives.PAS_VANGUARD_COREMETER ) )
		passive = "能量盜取"
	else if ( antiRodeo.HasMod( "pas_vanguard_rearm" ) )
		passive = "疾速武裝"
	else if ( SoulHasPassive( soul, ePassives.PAS_VANGUARD_DOOM ) )
		passive = "適者生存"
	// upgrade 1
	string firstUpgrade = ""
	if ( primaryMods.contains( "arc_rounds" ) || primaryMods.contains( "arc_rounds_with_battle_rifle" ) )
		firstUpgrade = "電弧彈藥"
	else if ( specialMods.contains( "energy_transfer" ) || specialMods.contains( "energy_field_energy_transfer" ) )
		firstUpgrade = "能量轉換"
	else if ( ordnanceMods.contains( "missile_racks" ) || ordnanceMods.contains( "upgradeCore_MissileRack_Vanguard" ) )
		firstUpgrade = "飛彈架"
	// upgrade 2
	string secondUpgrade = ""
	if ( primaryMods.contains( "rapid_reload" ) )
		secondUpgrade = "快速武裝"
	else if ( specialMods.contains( "energy_field" ) || specialMods.contains( "energy_field_energy_transfer" ) )
		secondUpgrade = "能量場"
	else if ( soul.GetTitanSoulNetInt( "upgradeCount" ) >= 2 && SoulHasPassive( soul, ePassives.PAS_VANGUARD_CORE5 ) )
		secondUpgrade = "漩渦"
	// upgrade 3
	string finalUpgrade = ""
	if ( weapon.HasMod( "battle_rifle" ) || weapon.HasMod( "arc_rounds_with_battle_rifle" ) )
		finalUpgrade = "加速器"
	else if ( ordnance.HasMod( "upgradeCore_Vanguard" ) || ordnance.HasMod( "upgradeCore_MissileRack_Vanguard" ) )
		finalUpgrade = "多目標飛彈"
	else if ( soul.GetTitanSoulNetInt( "upgradeCount" ) >= 3 && SoulHasPassive( soul, ePassives.PAS_VANGUARD_CORE8 ) )
		finalUpgrade = "高級機種"

	string displayName = "帝王 技能組"
	if ( passive != "" || firstUpgrade != "" || secondUpgrade != "" || finalUpgrade != "" )
		displayName += "【" // start

	if ( passive != "" )
		displayName += passive
	if ( firstUpgrade != "" )
		displayName += " " + firstUpgrade // add a space
	if ( secondUpgrade != "" )
		displayName += " " + secondUpgrade // add a space
	if ( finalUpgrade != "" )
		displayName += " " + finalUpgrade // add a space

	if ( passive != "" || firstUpgrade != "" || secondUpgrade != "" || finalUpgrade != "" )
		displayName += "】" // end

	return displayName
}

void function SwitchOffMonarchLoadout( entity titan )
{
	// bodygroup
	int statesIndex = titan.FindBodyGroup( "states" )
	if ( statesIndex > 0 )
		titan.SetBodygroup( statesIndex, 0 )

	// maelstrom
    entity smokeWeapon = titan.GetOffhandWeapon( OFFHAND_INVENTORY )
    if ( IsValid( smokeWeapon ) ) // take off maelstrom, will be given by loadout funcs
    {
        array<string> mods = smokeWeapon.GetMods()
        mods.removebyvalue( "maelstrom" )
        smokeWeapon.SetMods( mods )
    }

    // superior chassis
    entity soul = titan.GetTitanSoul()
    if ( IsValid( soul ) )
    {
        if ( titan.IsPlayer() )
        {
            array<string> settingMods = titan.GetPlayerSettingsMods()
            if ( settingMods.contains( "core_health_upgrade" ) ) // monarch upgrade
			{
				if ( !GetDoomedState( titan ) )
				{
					array<string> classMods = titan.GetPlayerSettingsMods()
					classMods.removebyvalue( "core_health_upgrade" ) // remove existing classmod
					// update health and class
					int curHealth = titan.GetHealth()
					titan.SetPlayerSettingsWithMods( titan.GetPlayerSettings(), classMods )
					int newMaxHealth = titan.GetMaxHealth()
					titan.SetHealth( min( curHealth, newMaxHealth ) )

					soul.soul.titanLoadout.setFileMods.removebyvalue( "core_health_upgrade" ) // remove from setFileMods
				}

				// here goes a problem: a monarch with superior chassis cannot update it's health bar if it switch to another final upgrade with same upgradeCount
				soul.SetPreventCrits( false ) // clean up
			}
        }
    }
}

///// utilities
void function TakeTitanEarnMeterSmoke( entity titan )
{
	titan.EndSignal( "OnDestroy" )
	WaitFrame()

	titan.TakeOffhandWeapon( OFFHAND_INVENTORY )
}

string function GetTitanPassiveType( entity titan )
{
    entity soul = titan.GetTitanSoul()

	if(
		SoulHasPassive( soul, ePassives.PAS_ION_WEAPON ) ||
		SoulHasPassive( soul, ePassives.PAS_TONE_WEAPON ) ||
		SoulHasPassive( soul, ePassives.PAS_SCORCH_WEAPON ) ||
		SoulHasPassive( soul, ePassives.PAS_LEGION_WEAPON ) ||
		SoulHasPassive( soul, ePassives.PAS_RONIN_WEAPON ) ||
		SoulHasPassive( soul, ePassives.PAS_NORTHSTAR_WEAPON )
	)
		return "Weapon"
	if(
		SoulHasPassive( soul, ePassives.PAS_ION_TRIPWIRE ) ||
		SoulHasPassive( soul, ePassives.PAS_TONE_SONAR ) ||
		SoulHasPassive( soul, ePassives.PAS_SCORCH_SELFDMG ) ||
		SoulHasPassive( soul, ePassives.PAS_LEGION_SPINUP ) ||
		SoulHasPassive( soul, ePassives.PAS_RONIN_PHASE ) ||
		SoulHasPassive( soul, ePassives.PAS_NORTHSTAR_OPTICS )
	)
		return "Tactical"
	if(
		SoulHasPassive( soul, ePassives.PAS_ION_WEAPON_ADS ) ||
		SoulHasPassive( soul, ePassives.PAS_TONE_ROCKETS ) ||
		SoulHasPassive( soul, ePassives.PAS_SCORCH_FIREWALL ) ||
		SoulHasPassive( soul, ePassives.PAS_LEGION_CHARGESHOT ) ||
		SoulHasPassive( soul, ePassives.PAS_RONIN_ARCWAVE ) ||
		SoulHasPassive( soul, ePassives.PAS_NORTHSTAR_CLUSTER )
	)
		return "Offence"
	if(
		SoulHasPassive( soul, ePassives.PAS_ION_VORTEX ) ||
		SoulHasPassive( soul, ePassives.PAS_TONE_WALL ) ||
		SoulHasPassive( soul, ePassives.PAS_SCORCH_SHIELD ) ||
		SoulHasPassive( soul, ePassives.PAS_LEGION_GUNSHIELD ) ||
		SoulHasPassive( soul, ePassives.PAS_RONIN_AUTOSHIFT ) ||
		SoulHasPassive( soul, ePassives.PAS_NORTHSTAR_TRAP )
	)
		return "Defence"
	if(
		SoulHasPassive( soul, ePassives.PAS_ION_LASERCANNON ) ||
		SoulHasPassive( soul, ePassives.PAS_TONE_BURST ) ||
		SoulHasPassive( soul, ePassives.PAS_SCORCH_FLAMECORE ) ||
		SoulHasPassive( soul, ePassives.PAS_LEGION_SMARTCORE ) ||
		SoulHasPassive( soul, ePassives.PAS_RONIN_SWORDCORE ) ||
		SoulHasPassive( soul, ePassives.PAS_NORTHSTAR_FLIGHTCORE )
	)
		return "Core"

	return "Monarch"
}

void function RemoveUnmatchedPassive( entity titan )
{
    if( !titan.IsTitan() )
		return
	if( !titan.IsPlayer() )
		return

	string charaName = GetTitanCharacterName( titan )

	// ion
    if ( charaName != "ion" )
	{
		TakePassive( titan, ePassives.PAS_ION_TRIPWIRE )
		TakePassive( titan, ePassives.PAS_ION_VORTEX )
		TakePassive( titan, ePassives.PAS_ION_LASERCANNON )
		TakePassive( titan, ePassives.PAS_ION_WEAPON )
		TakePassive( titan, ePassives.PAS_ION_WEAPON_ADS )
	}

	// tone
    if ( charaName != "tone" )
	{
        TakePassive( titan, ePassives.PAS_TONE_BURST )
		TakePassive( titan, ePassives.PAS_TONE_ROCKETS )
		TakePassive( titan, ePassives.PAS_TONE_SONAR )
		TakePassive( titan, ePassives.PAS_TONE_WALL )
		TakePassive( titan, ePassives.PAS_TONE_WEAPON )
	}

	// ronin
	if ( charaName != "ronin" )
	{
        TakePassive( titan, ePassives.PAS_RONIN_ARCWAVE )
		TakePassive( titan, ePassives.PAS_RONIN_AUTOSHIFT )
		TakePassive( titan, ePassives.PAS_RONIN_PHASE )
		TakePassive( titan, ePassives.PAS_RONIN_SWORDCORE )
		TakePassive( titan, ePassives.PAS_RONIN_WEAPON )
	}

	// northstar
	if ( charaName != "northstar" )
	{
        TakePassive( titan, ePassives.PAS_NORTHSTAR_CLUSTER )
		TakePassive( titan, ePassives.PAS_NORTHSTAR_FLIGHTCORE )
		TakePassive( titan, ePassives.PAS_NORTHSTAR_OPTICS )
		TakePassive( titan, ePassives.PAS_NORTHSTAR_TRAP )
		TakePassive( titan, ePassives.PAS_NORTHSTAR_WEAPON )
	}

	// scorch
    if ( charaName != "scorch" )
	{
        TakePassive( titan, ePassives.PAS_SCORCH_FIREWALL )
		TakePassive( titan, ePassives.PAS_SCORCH_FLAMECORE )
		TakePassive( titan, ePassives.PAS_SCORCH_SELFDMG )
		TakePassive( titan, ePassives.PAS_SCORCH_SHIELD )
		TakePassive( titan, ePassives.PAS_SCORCH_WEAPON )
	}

	// legion
    if ( charaName != "legion" )
	{
        TakePassive( titan, ePassives.PAS_LEGION_CHARGESHOT )
		TakePassive( titan, ePassives.PAS_LEGION_GUNSHIELD )
		TakePassive( titan, ePassives.PAS_LEGION_SMARTCORE )
		TakePassive( titan, ePassives.PAS_LEGION_SPINUP )
		TakePassive( titan, ePassives.PAS_LEGION_WEAPON )
	}

}

void function ChangeSoulTitanExecution( entity soul, string desiredRef, string desiredRandomRef, bool checkPrime = true )
{
	TitanLoadoutDef loadout = soul.soul.titanLoadout
	
	string curRef = loadout.titanExecution
	bool isRandom = curRef.find( "random" ) != null //
	//print( "isRandom: " + string ( isRandom ) )
	if ( isRandom )
	{
		//print( "soul has random execution, try changing to new one: " + desiredRandomRef )
		soul.soul.titanLoadout.titanExecution = desiredRandomRef
		return
	}

	// non-random checks
	string primeSuffix = ""
	if ( checkPrime && loadout.isPrime == "titan_is_prime" )
		primeSuffix = "_prime"
	string newRef = desiredRef + primeSuffix
	//print( "try changing to execution: " + newRef )
	soul.soul.titanLoadout.titanExecution = newRef
}
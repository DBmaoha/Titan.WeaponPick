// 11.27: Changed all settings to "titan_soul" entity instead of player
untyped // I really don't like this thing but .SetPlayerSettings() need it...

global function TitanReplace_Init

///// acrossFile utilities
global function TitanReplace_SetTitanLoadoutReplace

///// titanType utilities
global function TitanReplace_BecomeIon
global function TitanReplace_BecomeTone
global function TitanReplace_BecomeRonin
global function TitanReplace_BecomeNorthstar
global function TitanReplace_BecomeScorch
global function TitanReplace_BecomeLegion
global function TitanReplace_BecomeMonarch

struct
{
	// settings
	bool defaultReplaceEnabled = false

	// player table
	table<entity, string> soulTitleTable
	table<entity, string> soulPassiveTable // for saving player's starter passiveType
	table<entity, string> soulExecutionRefTable // for saving player's starter executions
} file

void function TitanReplace_Init() 
{
	AddSpawnCallback( "npc_titan", OnTitanSpawned )
	AddCallback_OnPilotBecomesTitan( SetPlayerTitanTitle )

	RegisterDefaultTitanPickCharcters()
}

void function OnTitanSpawned( entity titan )
{
	TitanReplace_SetTitanLoadoutReplace( titan )
}

// default replace
void function TitanReplace_SetTitanLoadoutReplace( entity titan )
{
	// always init everything
	entity titanSoul = titan.GetTitanSoul()
	if( !IsValid( titanSoul ) ) // soul not spawned yet, mostly because disembarking, no worries
		return
	TitanReplace_InitSoulSettings( titanSoul ) // init! robbed monarch from npc pilots won't upgrade your weapons( shield regen only ), which means it's no need to setting a "titanSoul.s.disableTitanPick" for them. perfect

	// following are player titans( pet titans )
	entity player = GetPetTitanOwner( titan )
	if( !IsValid( player ) )
		return
	if ( "spawnWithoutSoul" in titan.s )
	{
		// this is defined in CreateAutoTitanForPlayer_ForTitanTitanReplace_BecomesPilot(), mark the titan as "disembarked" not "hotdropping"
		if ( expect bool ( titan.s.spawnWithoutSoul ) )
			return
	}

	// get passives and executionrefs here
	file.soulPassiveTable[ titanSoul ] = GetTitanPassiveType( titan ) // for saving player's starter passiveType
	file.soulExecutionRefTable[ titanSoul ] = titanSoul.soul.titanLoadout.titanExecution // for saving player's starter executions
	//print( "soul " + string( titanSoul ) + " 's executionRef is: " + file.soulExecutionRefTable[ titanSoul ] )

	// playlistvar check
    if ( GetCurrentPlaylistVarInt( "titan_weapon_drops", 0 ) == 0 ) // don't run loadout functions automatically if settings disabled
        return

	asset modelName = titan.GetModelName()
	//print( "modelName is: " + string( modelName ) )

	switch( modelName )
	{
		case $"models/titans/medium/titan_medium_vanguard.mdl":
			TitanPick_SoulSetEnableWeaponPick( titanSoul, false ) // setting players unable to replace weapons from ground
			TitanPick_SoulShouldSaveOffhandWeapons( titanSoul, true ) // setting titan save their offhand upgrades on death
			break
	}
}

void function SetPlayerTitanTitle( entity player, entity titan )
{
	thread SetPlayerTitanTitle_Threaded( player ) // needs thread, to make soul valid
}

void function SetPlayerTitanTitle_Threaded( entity player )
{
	player.EndSignal( "OnDestroy" )
	WaitFrame()

	entity titanSoul = player.GetTitanSoul()
	if( !IsValid( titanSoul ) )
		return
	if ( titanSoul in file.soulTitleTable )
	{
		string soulSaveTitle = file.soulTitleTable[ titanSoul ]
		if( soulSaveTitle != "" )
		{
			//print( "soulSaveTitle: " + soulSaveTitle )
			if( IsAlive( player ) )
				player.SetTitle( soulSaveTitle )
		}
	}
	//else
	//	print( "can't find titan's title!" )
}

///// settings functions!
void function TitanReplace_InitSoulSettings( entity titanSoul ) // both using for players and titanSouls
{
	if ( !( titanSoul in file.soulTitleTable ) )
		file.soulTitleTable[ titanSoul ] <- ""
	if ( !( titanSoul in file.soulPassiveTable ) )
		file.soulPassiveTable[ titanSoul ] <- ""
	if ( !( titanSoul in file.soulExecutionRefTable ) )
		file.soulExecutionRefTable[ titanSoul ] <- ""
}
///////////


///// loadout functions
void function TitanReplace_BecomeIon( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心启动期间不可以更换装备", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }
			if( !isPickup )
			{
				foreach( entity weapon in titan.GetMainWeapons() )
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
			}
            foreach( entity offhand in titan.GetOffhandWeapons() )
			{
				if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
                	titan.TakeWeaponNow( offhand.GetWeaponClassName() )
			}
			if( !isSpawning )
			{
            	SendHudMessage( player, "更换至 离子 泰坦技能组", -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
				player.SetTitle( "#TITAN_ION" )
			}
			file.soulTitleTable[ soul ] = "#TITAN_ION"
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "ion" )
			TitanPick_SoulShouldSaveOffhandWeapons( soul, false )
			TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )
			
			string passiveType = file.soulPassiveTable[ soul ]
			RemoveUnmatchedPassive( titan )

			//Defence
			if( passiveType == "Defence" )
			{
				titan.GiveOffhandWeapon("mp_titanweapon_vortex_shield_ion", OFFHAND_SPECIAL, ["pas_ion_vortex"] )
				GivePassive( titan, ePassives.PAS_ION_VORTEX )
			}
			else
				titan.GiveOffhandWeapon("mp_titanweapon_vortex_shield_ion", OFFHAND_SPECIAL)

			//Tactical
			if( passiveType == "Tactical" )
			{
				titan.GiveOffhandWeapon("mp_titanability_laser_trip", OFFHAND_ANTIRODEO, ["pas_ion_tripwire"] )
				GivePassive( titan, ePassives.PAS_ION_TRIPWIRE )
			}
			else
				titan.GiveOffhandWeapon("mp_titanability_laser_trip", OFFHAND_ANTIRODEO )

			//Offence
			titan.GiveOffhandWeapon("mp_titanweapon_laser_lite", OFFHAND_ORDNANCE )

			//Weapon
            if( !isPickup )
			{
                if( passiveType == "Weapon" )
                {
                    titan.GiveWeapon ("mp_titanweapon_particle_accelerator", ["pas_ion_weapon"])
                    GivePassive( titan, ePassives.PAS_ION_WEAPON )
                }
                else if( passiveType == "Offence" )
				{
                    titan.GiveWeapon ("mp_titanweapon_particle_accelerator", ["pas_ion_weapon_ads"])
					GivePassive( titan, ePassives.PAS_ION_WEAPON_ADS )
				}
				else
                    titan.GiveWeapon ("mp_titanweapon_particle_accelerator")
            }

			//Titan Core
			if( passiveType == "Core" )
			{
				titan.GiveOffhandWeapon( "mp_titancore_laser_cannon", OFFHAND_EQUIPMENT, ["pas_ion_lasercannon"] )
				GivePassive( titan, ePassives.PAS_ION_LASERCANNON )
			}
			else
				titan.GiveOffhandWeapon( "mp_titancore_laser_cannon", OFFHAND_EQUIPMENT )
		
            //Melee
            titan.GiveOffhandWeapon( "melee_titan_punch_ion", OFFHAND_MELEE )
			
			//Executions
			if ( isPickup )
			{
				if ( GetSoulTitanSubClass( soul ) == "atlas" ) // atlas titan
				{
					ChangeSoulTitanExecution( soul, "execution_ion", "execution_random_0" )
					MeleeSyncedTitan_SetSoulUseExecutionCallback( soul, false )
				}
				else // other titans
				{
					soul.soul.titanLoadout.titanExecution = file.soulExecutionRefTable[ soul ] // restore to starter execution
					MeleeSyncedTitan_SetSoulUseExecutionCallback( soul, true ) // enable execution callbacks for them
				}
			}
        }
	}
}

void function TitanReplace_BecomeTone( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心启动期间不可以更换装备", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }
			if( !isPickup )
			{
				foreach( entity weapon in titan.GetMainWeapons() )
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
			}
            foreach( entity offhand in titan.GetOffhandWeapons() )
			{
				if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
                	titan.TakeWeaponNow( offhand.GetWeaponClassName() )
			}
			if( !isSpawning )
			{
            	SendHudMessage( player, "更换至 强力 泰坦技能组", -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
				player.SetTitle( "#TITAN_TONE" )
			}
			file.soulTitleTable[ soul ] = "#TITAN_TONE"
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "tone" )
			TitanPick_SoulShouldSaveOffhandWeapons( soul, false )
			TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )

			string passiveType = file.soulPassiveTable[ soul ]
			RemoveUnmatchedPassive( titan )

			//Defence
			if( passiveType == "Defence" )
            {
				titan.GiveOffhandWeapon("mp_titanability_particle_wall", OFFHAND_SPECIAL )
                GivePassive( titan, ePassives.PAS_TONE_WALL )
            }
            else
				titan.GiveOffhandWeapon("mp_titanability_particle_wall", OFFHAND_SPECIAL)

			//Tactical
			if( passiveType == "Tactical" )
			{
				titan.GiveOffhandWeapon("mp_titanability_sonar_pulse", OFFHAND_ANTIRODEO, ["pas_tone_sonar"] )
				GivePassive( titan, ePassives.PAS_TONE_SONAR )
			}
			else
				titan.GiveOffhandWeapon("mp_titanability_sonar_pulse", OFFHAND_ANTIRODEO )

			//Offence
            if( passiveType == "Offence" )
			{
				titan.GiveOffhandWeapon("mp_titanweapon_tracker_rockets", OFFHAND_ORDNANCE, ["pas_tone_rockets"] )
				GivePassive( titan, ePassives.PAS_TONE_ROCKETS )
			}
			else
                titan.GiveOffhandWeapon("mp_titanweapon_tracker_rockets", OFFHAND_ORDNANCE )

			//Weapon
            if( !isPickup )
			{
                if( passiveType == "Weapon" )
				{
                    titan.GiveWeapon ("mp_titanweapon_sticky_40mm", ["pas_tone_weapon"])
					GivePassive( titan, ePassives.PAS_TONE_WEAPON )
				}
				else if( passiveType == "Core" )
				{
                    titan.GiveWeapon ("mp_titanweapon_sticky_40mm", ["pas_tone_burst"])
					GivePassive( titan, ePassives.PAS_TONE_BURST )
				}
				else
                    titan.GiveWeapon ("mp_titanweapon_sticky_40mm")
            }

			//Titan Core
			titan.GiveOffhandWeapon( "mp_titancore_salvo_core", OFFHAND_EQUIPMENT )
		
            //Melee
            titan.GiveOffhandWeapon( "melee_titan_punch_tone", OFFHAND_MELEE )

			//Executions
			if ( isPickup )
			{
				if ( GetSoulTitanSubClass( soul ) == "atlas" ) // atlas titan
				{
					ChangeSoulTitanExecution( soul, "execution_tone", "execution_random_4" )
					MeleeSyncedTitan_SetSoulUseExecutionCallback( soul, false )
				}
				else // other titans
				{
					soul.soul.titanLoadout.titanExecution = file.soulExecutionRefTable[ soul ] // restore to starter execution
					MeleeSyncedTitan_SetSoulUseExecutionCallback( soul, true ) // enable execution callbacks for them
				}
			}
        }
	}
}

void function TitanReplace_BecomeRonin( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心启动期间不可以更换装备", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }
			if( !isPickup )
			{
				foreach( entity weapon in titan.GetMainWeapons() )
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
			}
            foreach( entity offhand in titan.GetOffhandWeapons() )
			{
				if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
                	titan.TakeWeaponNow( offhand.GetWeaponClassName() )
			}
			if( !isSpawning )
			{
           		SendHudMessage( player, "更换至 浪人 泰坦技能组", -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
            	player.SetTitle( "#TITAN_RONIN" )
			}
			file.soulTitleTable[ soul ] = "#TITAN_RONIN"
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "ronin" )
			TitanPick_SoulShouldSaveOffhandWeapons( soul, false )
			TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )

			string passiveType = file.soulPassiveTable[ soul ]
			RemoveUnmatchedPassive( titan )

			//Defence
            titan.GiveOffhandWeapon("mp_titanability_basic_block", OFFHAND_SPECIAL )

			//Tactical
			if( passiveType == "Defence" )
            {
				titan.GiveOffhandWeapon("mp_titanability_phase_dash", OFFHAND_ANTIRODEO )
                GivePassive( titan, ePassives.PAS_RONIN_AUTOSHIFT )
            }
            else if( passiveType == "Tactical" )
			{
                titan.GiveOffhandWeapon("mp_titanability_phase_dash", OFFHAND_ANTIRODEO, ["pas_ronin_phase"] )
				GivePassive( titan, ePassives.PAS_RONIN_PHASE )
			}
			else
				titan.GiveOffhandWeapon("mp_titanability_phase_dash", OFFHAND_ANTIRODEO)

			//Offence
            if( passiveType == "Offence" )
			{
				titan.GiveOffhandWeapon("mp_titanweapon_arc_wave", OFFHAND_ORDNANCE, ["pas_ronin_arcwave"] )
				GivePassive( titan, ePassives.PAS_RONIN_ARCWAVE )
			}
			else
                titan.GiveOffhandWeapon("mp_titanweapon_arc_wave", OFFHAND_ORDNANCE )

			//Weapon
            if( !isPickup )
			{
                if( passiveType == "Weapon" )
				{
                    titan.GiveWeapon ("mp_titanweapon_leadwall", ["pas_ronin_weapon"])
					GivePassive( titan, ePassives.PAS_RONIN_WEAPON )
				}
				else
                    titan.GiveWeapon ("mp_titanweapon_leadwall")
            }

			//Titan Core
            if( passiveType == "Core" )
			{
				titan.GiveOffhandWeapon( "mp_titancore_shift_core", OFFHAND_EQUIPMENT, ["pas_ronin_swordcore"] )
				GivePassive( titan, ePassives.PAS_RONIN_SWORDCORE )
			}
			else
				titan.GiveOffhandWeapon( "mp_titancore_shift_core", OFFHAND_EQUIPMENT )
		
            //Melee
            titan.GiveOffhandWeapon( "melee_titan_sword", OFFHAND_MELEE )

			//Executions
			if ( isPickup )
			{
				if ( GetSoulTitanSubClass( soul ) == "stryder" ) // stryder titan
				{
					ChangeSoulTitanExecution( soul, "execution_ronin", "execution_random_3" )
					MeleeSyncedTitan_SetSoulUseExecutionCallback( soul, false )
				}
				else // other titans
				{
					soul.soul.titanLoadout.titanExecution = file.soulExecutionRefTable[ soul ] // restore to starter execution
					MeleeSyncedTitan_SetSoulUseExecutionCallback( soul, true ) // enable execution callbacks for them
				}
			}
        }
	}
}

void function TitanReplace_BecomeNorthstar( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心启动期间不可以更换装备", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }
			if( !isPickup )
			{
				foreach( entity weapon in titan.GetMainWeapons() )
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
			}
            foreach( entity offhand in titan.GetOffhandWeapons() )
			{
				if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
                	titan.TakeWeaponNow( offhand.GetWeaponClassName() )
			}
			if( !isSpawning )
			{
            	SendHudMessage( player, "更换至 北极星 泰坦技能组", -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
            	player.SetTitle( "#TITAN_NORTHSTAR" )
			}
			file.soulTitleTable[ soul ] = "#TITAN_NORTHSTAR"
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "northstar" )
			TitanPick_SoulShouldSaveOffhandWeapons( soul, false )
			TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )

			string passiveType = file.soulPassiveTable[ soul ]
			RemoveUnmatchedPassive( titan )

			//Defence
            if( passiveType == "Defence" )
			{
                titan.GiveOffhandWeapon("mp_titanability_tether_trap", OFFHAND_SPECIAL, ["pas_northstar_trap"] )
				GivePassive( titan, ePassives.PAS_NORTHSTAR_TRAP )
			}
			else
                titan.GiveOffhandWeapon("mp_titanability_tether_trap", OFFHAND_SPECIAL )

			//Tacticals, northstar is a bit special
			if( passiveType == "Core" )
                titan.GiveOffhandWeapon("mp_titanability_hover", OFFHAND_ANTIRODEO )
			else
				titan.GiveOffhandWeapon("mp_titanability_hover", OFFHAND_ANTIRODEO)

			//Offence
            if( passiveType == "Offence" )
			{
				titan.GiveOffhandWeapon("mp_titanweapon_dumbfire_rockets", OFFHAND_ORDNANCE, ["pas_northstar_cluster"] )
				GivePassive( titan, ePassives.PAS_NORTHSTAR_CLUSTER )
			}
			else
                titan.GiveOffhandWeapon("mp_titanweapon_dumbfire_rockets", OFFHAND_ORDNANCE )

			//Weapon
            if( !isPickup )
			{
                if( passiveType == "Weapon" )
				{
                    titan.GiveWeapon ("mp_titanweapon_sniper", ["pas_northstar_weapon"])
					GivePassive( titan, ePassives.PAS_NORTHSTAR_WEAPON )
				}
				else if( passiveType == "Tactical" )
				{
					titan.GiveWeapon ("mp_titanweapon_sniper", ["pas_northstar_optics"])
					GivePassive( titan, ePassives.PAS_NORTHSTAR_OPTICS )
				}
				else
                    titan.GiveWeapon ("mp_titanweapon_sniper")
            }

			//Titan Core
            if( passiveType == "Core" )
            {
				titan.GiveOffhandWeapon( "mp_titancore_flight_core", OFFHAND_EQUIPMENT )
                GivePassive( titan, ePassives.PAS_NORTHSTAR_FLIGHTCORE )
            }
            else
				titan.GiveOffhandWeapon( "mp_titancore_flight_core", OFFHAND_EQUIPMENT )
		
            //Melee
            titan.GiveOffhandWeapon( "melee_titan_punch_northstar", OFFHAND_MELEE )

			//Executions
			if ( isPickup )
			{
				if ( GetSoulTitanSubClass( soul ) == "stryder" ) // stryder titan
				{
					ChangeSoulTitanExecution( soul, "execution_northstar", "execution_random_2" )
					MeleeSyncedTitan_SetSoulUseExecutionCallback( soul, false )
				}
				else // other titans
				{
					soul.soul.titanLoadout.titanExecution = file.soulExecutionRefTable[ soul ] // restore to starter execution
					MeleeSyncedTitan_SetSoulUseExecutionCallback( soul, true ) // enable execution callbacks for them
				}
			}
        }
	}
}

void function TitanReplace_BecomeScorch( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心启动期间不可以更换装备", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }
			if( !isPickup )
			{
				foreach( entity weapon in titan.GetMainWeapons() )
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
			}
            foreach( entity offhand in titan.GetOffhandWeapons() )
			{
				if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
                	titan.TakeWeaponNow( offhand.GetWeaponClassName() )
			}
			if( !isSpawning )
			{
            	SendHudMessage( player, "更换至 烈焰 泰坦技能组", -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
            	player.SetTitle( "#TITAN_SCORCH" )
			}
			file.soulTitleTable[ soul ] = "#TITAN_SCORCH"
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "scorch" )
			TitanPick_SoulShouldSaveOffhandWeapons( soul, false )
			TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )

			string passiveType = file.soulPassiveTable[ soul ]
			RemoveUnmatchedPassive( titan )

			//Defence
            if( passiveType == "Defence" )
			{
                titan.GiveOffhandWeapon("mp_titanweapon_heat_shield", OFFHAND_SPECIAL, ["pas_scorch_shield"] )
				GivePassive( titan, ePassives.PAS_SCORCH_SHIELD )
			}
			else
                titan.GiveOffhandWeapon("mp_titanweapon_heat_shield", OFFHAND_SPECIAL )

			//Tacticals, scorch is a bit special
			if( passiveType == "Tactical" )
                GivePassive( titan, ePassives.PAS_SCORCH_SELFDMG )
            titan.GiveOffhandWeapon("mp_titanability_slow_trap", OFFHAND_ANTIRODEO )

			//Offence
            if( passiveType == "Offence" )
			{
				titan.GiveOffhandWeapon("mp_titanweapon_flame_wall", OFFHAND_ORDNANCE, ["pas_scorch_firewall"] )
				GivePassive( titan, ePassives.PAS_SCORCH_FIREWALL )
			}
			else
                titan.GiveOffhandWeapon("mp_titanweapon_flame_wall", OFFHAND_ORDNANCE )

			//Weapon
            if( !isPickup )
			{
                if( passiveType == "Weapon" )
				{
                    titan.GiveWeapon ("mp_titanweapon_meteor", ["pas_scorch_weapon"])
					GivePassive( titan, ePassives.PAS_SCORCH_WEAPON )
				}
				else
                    titan.GiveWeapon ("mp_titanweapon_meteor")
            }

			//Titan Core
            if( passiveType == "Core" )
			{
				titan.GiveOffhandWeapon( "mp_titancore_flame_wave", OFFHAND_EQUIPMENT, ["pas_scorch_flamecore"] )
				GivePassive( titan, ePassives.PAS_SCORCH_FLAMECORE )
			}
			else
				titan.GiveOffhandWeapon( "mp_titancore_flame_wave", OFFHAND_EQUIPMENT )
		
            //Melee
            titan.GiveOffhandWeapon( "melee_titan_punch_scorch", OFFHAND_MELEE )

			//Executions
			if ( isPickup )
			{
				if ( GetSoulTitanSubClass( soul ) == "ogre" ) // ogre titan
				{
					ChangeSoulTitanExecution( soul, "execution_scorch", "execution_random_1" )
					MeleeSyncedTitan_SetSoulUseExecutionCallback( soul, false )
				}
				else // other titans
				{
					soul.soul.titanLoadout.titanExecution = file.soulExecutionRefTable[ soul ] // restore to starter execution
					MeleeSyncedTitan_SetSoulUseExecutionCallback( soul, true ) // enable execution callbacks for them
				}
			}
        }
	}
}

void function TitanReplace_BecomeLegion( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心启动期间不可以更换装备", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }
			if( !isPickup )
			{
				foreach( entity weapon in titan.GetMainWeapons() )
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
			}
            foreach( entity offhand in titan.GetOffhandWeapons() )
			{
				if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
                	titan.TakeWeaponNow( offhand.GetWeaponClassName() )
			}
			if( !isSpawning )
			{
            	SendHudMessage( player, "更换至 军团 泰坦技能组", -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
            	player.SetTitle( "#TITAN_LEGION" )
			}
			file.soulTitleTable[ soul ] = "#TITAN_LEGION"
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "legion" )
			TitanPick_SoulShouldSaveOffhandWeapons( soul, false )
			TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )

			string passiveType = file.soulPassiveTable[ soul ]
			RemoveUnmatchedPassive( titan )

			//Defence
            if( passiveType == "Defence" )
            {
                titan.GiveOffhandWeapon("mp_titanability_gun_shield", OFFHAND_SPECIAL )
                GivePassive( titan, ePassives.PAS_LEGION_GUNSHIELD )
            }
            else
                titan.GiveOffhandWeapon("mp_titanability_gun_shield", OFFHAND_SPECIAL )

			//Tacticals
            titan.GiveOffhandWeapon("mp_titanability_ammo_swap", OFFHAND_ANTIRODEO )

			//Offence
            if( passiveType == "Offence" )
			{
				titan.GiveOffhandWeapon("mp_titanability_power_shot", OFFHAND_ORDNANCE, ["pas_legion_chargeshot"] )
				GivePassive( titan, ePassives.PAS_LEGION_CHARGESHOT )
			}
			else
                titan.GiveOffhandWeapon("mp_titanability_power_shot", OFFHAND_ORDNANCE )

			//Weapon
            if( !isPickup )
			{
                if( passiveType == "Weapon" )
				{
                    titan.GiveWeapon ("mp_titanweapon_predator_cannon", ["pas_legion_weapon"])
					GivePassive( titan, ePassives.PAS_LEGION_WEAPON)
				}
				if( passiveType == "Tactical" )
				{
                    titan.GiveWeapon ("mp_titanweapon_predator_cannon", ["pas_legion_spinup"])
					GivePassive( titan, ePassives.PAS_LEGION_SPINUP )
				}
				else
                    titan.GiveWeapon ("mp_titanweapon_predator_cannon")
            }

			//Titan Core
            if( passiveType == "Core" )
			{
				titan.GiveOffhandWeapon( "mp_titancore_siege_mode", OFFHAND_EQUIPMENT, ["pas_legion_smartcore"] )
				GivePassive( titan, ePassives.PAS_LEGION_SMARTCORE )
			}
			else
				titan.GiveOffhandWeapon( "mp_titancore_siege_mode", OFFHAND_EQUIPMENT )
		
            //Melee
            titan.GiveOffhandWeapon( "melee_titan_punch_legion", OFFHAND_MELEE )

			if ( GetSoulTitanSubClass( soul ) == "ogre" ) // ogre titan
			{
				ChangeSoulTitanExecution( soul, "execution_legion", "execution_random_5" )
				MeleeSyncedTitan_SetSoulUseExecutionCallback( soul, false )
			}
			else // other titans
			{
				soul.soul.titanLoadout.titanExecution = file.soulExecutionRefTable[ soul ] // restore to starter execution
				MeleeSyncedTitan_SetSoulUseExecutionCallback( soul, true ) // enable execution callbacks for them
			}
        }
	}
}

void function TitanReplace_BecomeMonarch( entity titan, bool isPickup = false, bool isSpawning = false )
{
    if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心启动期间不可以更换装备", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }
			if( !isPickup )
			{
				foreach( entity weapon in titan.GetMainWeapons() )
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
			}
            foreach( entity offhand in titan.GetOffhandWeapons() )
			{
				if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
                	titan.TakeWeaponNow( offhand.GetWeaponClassName() )
			}
			if( !isSpawning )
			{
            	SendHudMessage( player, "更换至 帝王 泰坦技能组", -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
            	player.SetTitle( "#TITAN_VANGUARD" )
			}
			file.soulTitleTable[ soul ] = "#TITAN_VANGUARD"
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "vanguard" )
			TitanPick_SoulShouldSaveOffhandWeapons( soul, true )
			TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )

			string passiveType = file.soulPassiveTable[ soul ]
			RemoveUnmatchedPassive( titan )

			//Defence
			titan.GiveOffhandWeapon("mp_titanweapon_stun_laser", OFFHAND_SPECIAL )

			//Tactical
			titan.GiveOffhandWeapon("mp_titanability_rearm", OFFHAND_ANTIRODEO )

			//Offence
			titan.GiveOffhandWeapon("mp_titanweapon_salvo_rockets", OFFHAND_ORDNANCE )

			//Weapon
            if( !isPickup )
			{
                titan.GiveWeapon ("mp_titanweapon_xo16_vanguard")
            }

			//Titan Core
			titan.GiveOffhandWeapon( "mp_titancore_upgrade", OFFHAND_EQUIPMENT )
            soul.SetTitanSoulNetInt( "upgradeCount", 3 ) // so player can't upgrade, they can only receive shields
		
            //Melee
            titan.GiveOffhandWeapon( "melee_titan_punch_vanguard", OFFHAND_MELEE )

			
			//Executions
			if ( isPickup )
			{
				if ( GetSoulTitanSubClass( soul ) == "atlas" ) // atlas titan
				{
					ChangeSoulTitanExecution( soul, "execution_vangard", "execution_random_6", false ) // monarch don't have _prime suffix ones
					MeleeSyncedTitan_SetSoulUseExecutionCallback( soul, false )
				}
				else // other titans
				{
					soul.soul.titanLoadout.titanExecution = file.soulExecutionRefTable[ soul ] // restore to starter execution
					MeleeSyncedTitan_SetSoulUseExecutionCallback( soul, true ) // enable execution callbacks for them
				}
			}
        }
	}
}

///// titan pick loadout functions
void function RegisterDefaultTitanPickCharcters()
{
	RegisterIonTitanPick()
	RegisterToneTitanPick()
	RegisterRoninTitanPick()
	RegisterNorthstarTitanPick()
	RegisterScorchTitanPick()
	RegisterLegionTitanPick()
	RegisterMonarchTitanPick()
}

// ion
void function RegisterIonTitanPick()
{
	TitanPick_RegisterTitanWeaponDrop( "ion", IonWeaponWeaponPropFunc, IonWeaponDisplayNameFunc, TitanReplace_BecomeIon )
}

entity function IonWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()

	if ( weaponName != "mp_titanweapon_particle_accelerator" )
		return // return empty will cancel the weapon drop

	asset modelName = $"models/weapons/titan_particle_accelerator/w_titan_particle_accelerator.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function IonWeaponDisplayNameFunc( entity weapon )
{
	string weaponName = weapon.GetWeaponClassName()
    array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_particle_accelerator" )
		return "" // return empty will cancel the weapon drop

	if ( mods.contains( "pas_ion_weapon" ) )
		return "分裂槍【纏結能量】"
	if ( mods.contains( "pas_ion_weapon_ads" ) )
		return "分裂槍【折射鏡片】"
	return "分裂槍"
}

// tone
void function RegisterToneTitanPick()
{
	TitanPick_RegisterTitanWeaponDrop( "tone", ToneWeaponWeaponPropFunc, ToneWeaponDisplayNameFunc, TitanReplace_BecomeTone )
}

entity function ToneWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()

	if ( weaponName != "mp_titanweapon_sticky_40mm" )
		return // return empty will cancel the weapon drop

	asset modelName = $"models/weapons/thr_40mm/w_thr_40mm.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function ToneWeaponDisplayNameFunc( entity weapon )
{
	string weaponName = weapon.GetWeaponClassName()
    array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_sticky_40mm" )
		return "" // return empty will cancel the weapon drop

	if ( mods.contains( "pas_tone_weapon" ) )
            return "40mm追蹤機炮【強化追蹤彈藥】"
	if ( mods.contains( "pas_tone_burst" ) )
		return "40mm追蹤機炮【連發填充器】"
	return "40mm追蹤機炮"
}

// ronin
void function RegisterRoninTitanPick()
{
	TitanPick_RegisterTitanWeaponDrop( "ronin", RoninWeaponWeaponPropFunc, RoninWeaponDisplayNameFunc, TitanReplace_BecomeRonin )
}

entity function RoninWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()

	if ( weaponName != "mp_titanweapon_leadwall" )
		return // return empty will cancel the weapon drop

	asset modelName = $"models/weapons/titan_triple_threat/w_titan_triple_threat.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function RoninWeaponDisplayNameFunc( entity weapon )
{
	string weaponName = weapon.GetWeaponClassName()
    array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_leadwall" )
		return "" // return empty will cancel the weapon drop

	if ( mods.contains( "pas_ronin_weapon" ) )
            return "天女散花【彈跳彈藥】"
    return "天女散花"
}

// northstar
void function RegisterNorthstarTitanPick()
{
	TitanPick_RegisterTitanWeaponDrop( "northstar", NorthstarWeaponWeaponPropFunc, NorthstarWeaponDisplayNameFunc, TitanReplace_BecomeNorthstar )
}

entity function NorthstarWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()

	if ( weaponName != "mp_titanweapon_sniper" )
		return // return empty will cancel the weapon drop

	asset modelName = $"models/weapons/titan_sniper_rifle/w_titan_sniper_rifle.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function NorthstarWeaponDisplayNameFunc( entity weapon )
{
	string weaponName = weapon.GetWeaponClassName()
    array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_sniper" )
		return "" // return empty will cancel the weapon drop

	if ( mods.contains( "pas_northstar_optics" ) )
        return "電漿磁軌炮【威脅光鏡】"
	if ( mods.contains( "pas_northstar_weapon" ) )
		return "電漿磁軌炮【穿刺射擊】"
	return "電漿磁軌炮"
}

// scorch
void function RegisterScorchTitanPick()
{
	TitanPick_RegisterTitanWeaponDrop( "scorch", ScorchWeaponWeaponPropFunc, ScorchWeaponDisplayNameFunc, TitanReplace_BecomeScorch )
}

entity function ScorchWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()

	if ( weaponName != "mp_titanweapon_meteor" )
		return // return empty will cancel the weapon drop
	
	asset modelName = $"models/weapons/titan_thermite_launcher/w_titan_thermite_launcher.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function ScorchWeaponDisplayNameFunc( entity weapon )
{
	string weaponName = weapon.GetWeaponClassName()
    array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_meteor" )
		return "" // return empty will cancel the weapon drop

	if ( mods.contains( "pas_scorch_weapon" ) )
		return "T-203鋁熱劑發射器【野火投射器】"
	return "T-203鋁熱劑發射器"
}

// legion
void function RegisterLegionTitanPick()
{
	TitanPick_RegisterTitanWeaponDrop( "legion", LegionWeaponWeaponPropFunc, LegionWeaponDisplayNameFunc, TitanReplace_BecomeLegion )
	TitanPick_AddIllegalWeaponMod( "Smart_Core" )
	TitanPick_AddIllegalWeaponMod( "LongRangeAmmo" )
	TitanPick_AddIllegalWeaponMod( "CloseRangePowerShot" )
	TitanPick_AddIllegalWeaponMod( "pas_CloseRangePowerShot" )
	TitanPick_AddIllegalWeaponMod( "LongRangePowerShot" )
	TitanPick_AddIllegalWeaponMod( "pas_LongRangePowerShot" )
}

entity function LegionWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()

	if ( weaponName != "mp_titanweapon_predator_cannon" )
		return // return empty will cancel the weapon drop
	
	asset modelName = $"models/weapons/titan_predator/w_titan_predator.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function LegionWeaponDisplayNameFunc( entity weapon )
{
	string weaponName = weapon.GetWeaponClassName()
    array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_predator_cannon" )
		return "" // return empty will cancel the weapon drop

	if ( mods.contains( "pas_legion_weapon" ) )
		return "獵殺者機炮【強化彈藥容量】"
	if ( mods.contains( "pas_legion_spinup" ) )
		return "獵殺者機炮【輕合金】"
	return "獵殺者機炮"
}

// monarch, not sure if it's named "vanguard"
void function RegisterMonarchTitanPick()
{
	TitanPick_RegisterTitanWeaponDrop( "vanguard", MonarchWeaponWeaponPropFunc, MonarchWeaponDisplayNameFunc, TitanReplace_BecomeMonarch )
}

entity function MonarchWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()

	if ( weaponName != "mp_titanweapon_xo16_vanguard" )
		return // return empty will cancel the weapon drop

	asset modelName = $"models/weapons/titan_xo16_shorty/w_xo16shorty.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function MonarchWeaponDisplayNameFunc( entity weapon )
{
	entity titan = weapon.GetWeaponOwner()
	if ( !IsValid( titan ) )
		return ""
	string weaponName = weapon.GetWeaponClassName()
	if ( weaponName != "mp_titanweapon_xo16_vanguard" )
		return "" // return empty will cancel the weapon drop

	// mornach has variant mods
	entity special = titan.GetOffhandWeapon( OFFHAND_SPECIAL )
    entity ordnance = titan.GetOffhandWeapon( OFFHAND_ORDNANCE )
    entity antiRodeo = titan.GetOffhandWeapon( OFFHAND_ANTIRODEO )
	// upgrade 1
	string firstUpgrade = ""
	if ( weapon.HasMod( "arc_rounds" ) || weapon.HasMod( "arc_rounds_with_battle_rifle" ) )
		firstUpgrade = "電弧彈藥"
	else if ( IsValid( special ) && ( special.HasMod( "energy_transfer" ) || special.HasMod( "energy_field_energy_transfer" ) ) )
		firstUpgrade = "能量轉換"
	else if ( IsValid( ordnance ) && ( ordnance.HasMod( "missile_racks" ) || ordnance.HasMod( "upgradeCore_MissileRack_Vanguard" ) ) )
		firstUpgrade = "飛彈架"
	// upgrade 2, no support for maelstrom now
	string secondUpgrade = ""
	if ( weapon.HasMod( "rapid_reload" ) )
		secondUpgrade = "快速武裝"
	else if ( IsValid( special ) && ( special.HasMod( "energy_field" ) || special.HasMod( "energy_field_energy_transfer" ) ) )
		secondUpgrade = "能量場"
	// upgrade 3, no support for superior monarch now
	string finalUpgrade = ""
	if ( weapon.HasMod( "battle_rifle" ) || weapon.HasMod( "arc_rounds_with_battle_rifle" ) )
		finalUpgrade = "加速器"
	else if ( IsValid( ordnance ) && ( ordnance.HasMod( "upgradeCore_Vanguard" ) || ordnance.HasMod( "upgradeCore_MissileRack_Vanguard" ) ) )
		finalUpgrade = "多目標飛彈"

	string displayName = "XO-16"
	if ( firstUpgrade != "" || secondUpgrade != "" || finalUpgrade != "" )
		displayName += "【" // start

	if ( firstUpgrade != "" )
		displayName += firstUpgrade
	if ( secondUpgrade != "" )
		displayName += " " + secondUpgrade // add a space
	if ( finalUpgrade != "" )
		displayName += " " + finalUpgrade // add a space

	if ( firstUpgrade != "" || secondUpgrade != "" || finalUpgrade != "" )
		displayName += "】" // end

	return displayName
}

///// utilities
void function TakeTitanEarnMeterSmoke( entity titan )
{
	titan.EndSignal( "OnDestroy" )
	WaitFrame()

	titan.TakeOffhandWeapon( OFFHAND_INVENTORY )
}

string function GetTitanPassiveType( entity titan )
{
    entity soul = titan.GetTitanSoul()

	if(
		SoulHasPassive( soul, ePassives.PAS_ION_WEAPON ) ||
		SoulHasPassive( soul, ePassives.PAS_TONE_WEAPON ) ||
		SoulHasPassive( soul, ePassives.PAS_SCORCH_WEAPON ) ||
		SoulHasPassive( soul, ePassives.PAS_LEGION_WEAPON ) ||
		SoulHasPassive( soul, ePassives.PAS_RONIN_WEAPON ) ||
		SoulHasPassive( soul, ePassives.PAS_NORTHSTAR_WEAPON )
	)
		return "Weapon"
	if(
		SoulHasPassive( soul, ePassives.PAS_ION_TRIPWIRE ) ||
		SoulHasPassive( soul, ePassives.PAS_TONE_SONAR ) ||
		SoulHasPassive( soul, ePassives.PAS_SCORCH_SELFDMG ) ||
		SoulHasPassive( soul, ePassives.PAS_LEGION_SPINUP ) ||
		SoulHasPassive( soul, ePassives.PAS_RONIN_PHASE ) ||
		SoulHasPassive( soul, ePassives.PAS_NORTHSTAR_OPTICS )
	)
		return "Tactical"
	if(
		SoulHasPassive( soul, ePassives.PAS_ION_WEAPON_ADS ) ||
		SoulHasPassive( soul, ePassives.PAS_TONE_ROCKETS ) ||
		SoulHasPassive( soul, ePassives.PAS_SCORCH_FIREWALL ) ||
		SoulHasPassive( soul, ePassives.PAS_LEGION_CHARGESHOT ) ||
		SoulHasPassive( soul, ePassives.PAS_RONIN_ARCWAVE ) ||
		SoulHasPassive( soul, ePassives.PAS_NORTHSTAR_CLUSTER )
	)
		return "Offence"
	if(
		SoulHasPassive( soul, ePassives.PAS_ION_VORTEX ) ||
		SoulHasPassive( soul, ePassives.PAS_TONE_WALL ) ||
		SoulHasPassive( soul, ePassives.PAS_SCORCH_SHIELD ) ||
		SoulHasPassive( soul, ePassives.PAS_LEGION_GUNSHIELD ) ||
		SoulHasPassive( soul, ePassives.PAS_RONIN_AUTOSHIFT ) ||
		SoulHasPassive( soul, ePassives.PAS_NORTHSTAR_TRAP )
	)
		return "Defence"
	if(
		SoulHasPassive( soul, ePassives.PAS_ION_LASERCANNON ) ||
		SoulHasPassive( soul, ePassives.PAS_TONE_BURST ) ||
		SoulHasPassive( soul, ePassives.PAS_SCORCH_FLAMECORE ) ||
		SoulHasPassive( soul, ePassives.PAS_LEGION_SMARTCORE ) ||
		SoulHasPassive( soul, ePassives.PAS_RONIN_SWORDCORE ) ||
		SoulHasPassive( soul, ePassives.PAS_NORTHSTAR_FLIGHTCORE )
	)
		return "Core"

	return "Monarch"
}

void function RemoveUnmatchedPassive( entity titan )
{
    if( !titan.IsTitan() )
		return
	if( !titan.IsPlayer() )
		return

	string charaName = GetTitanCharacterName( titan )

	// ion
    if ( charaName != "ion" )
	{
		TakePassive( titan, ePassives.PAS_ION_TRIPWIRE )
		TakePassive( titan, ePassives.PAS_ION_VORTEX )
		TakePassive( titan, ePassives.PAS_ION_LASERCANNON )
		TakePassive( titan, ePassives.PAS_ION_WEAPON )
		TakePassive( titan, ePassives.PAS_ION_WEAPON_ADS )
	}

	// tone
    if ( charaName != "tone" )
	{
        TakePassive( titan, ePassives.PAS_TONE_BURST )
		TakePassive( titan, ePassives.PAS_TONE_ROCKETS )
		TakePassive( titan, ePassives.PAS_TONE_SONAR )
		TakePassive( titan, ePassives.PAS_TONE_WALL )
		TakePassive( titan, ePassives.PAS_TONE_WEAPON )
	}

	// ronin
	if ( charaName != "ronin" )
	{
        TakePassive( titan, ePassives.PAS_RONIN_ARCWAVE )
		TakePassive( titan, ePassives.PAS_RONIN_AUTOSHIFT )
		TakePassive( titan, ePassives.PAS_RONIN_PHASE )
		TakePassive( titan, ePassives.PAS_RONIN_SWORDCORE )
		TakePassive( titan, ePassives.PAS_RONIN_WEAPON )
	}

	// northstar
	if ( charaName != "northstar" )
	{
        TakePassive( titan, ePassives.PAS_NORTHSTAR_CLUSTER )
		TakePassive( titan, ePassives.PAS_NORTHSTAR_FLIGHTCORE )
		TakePassive( titan, ePassives.PAS_NORTHSTAR_OPTICS )
		TakePassive( titan, ePassives.PAS_NORTHSTAR_TRAP )
		TakePassive( titan, ePassives.PAS_NORTHSTAR_WEAPON )
	}

	// scorch
    if ( charaName != "scorch" )
	{
        TakePassive( titan, ePassives.PAS_SCORCH_FIREWALL )
		TakePassive( titan, ePassives.PAS_SCORCH_FLAMECORE )
		TakePassive( titan, ePassives.PAS_SCORCH_SELFDMG )
		TakePassive( titan, ePassives.PAS_SCORCH_SHIELD )
		TakePassive( titan, ePassives.PAS_SCORCH_WEAPON )
	}

	// legion
    if ( charaName != "legion" )
	{
        TakePassive( titan, ePassives.PAS_LEGION_CHARGESHOT )
		TakePassive( titan, ePassives.PAS_LEGION_GUNSHIELD )
		TakePassive( titan, ePassives.PAS_LEGION_SMARTCORE )
		TakePassive( titan, ePassives.PAS_LEGION_SPINUP )
		TakePassive( titan, ePassives.PAS_LEGION_WEAPON )
	}

}

void function ChangeSoulTitanExecution( entity soul, string desiredRef, string desiredRandomRef, bool checkPrime = true )
{
	TitanLoadoutDef loadout = soul.soul.titanLoadout
	
	string curRef = loadout.titanExecution
	bool isRandom = curRef.find( "random" ) != null //
	//print( "isRandom: " + string ( isRandom ) )
	if ( isRandom )
	{
		//print( "soul has random execution, try changing to new one: " + desiredRandomRef )
		soul.soul.titanLoadout.titanExecution = desiredRandomRef
		return
	}

	// non-random checks
	string primeSuffix = ""
	if ( checkPrime && loadout.isPrime == "titan_is_prime" )
		primeSuffix = "_prime"
	string newRef = desiredRef + primeSuffix
	//print( "try changing to execution: " + newRef )
	soul.soul.titanLoadout.titanExecution = newRef
}